from typing import Any, ClassVar, Optional

from typing import overload
import flags
import numpy
import pydrake.autodiffutils
import pydrake.common.cpp_template
import pydrake.common.eigen_geometry
import pydrake.common.value
import pydrake.math
import pydrake.multibody.math
import pydrake.symbolic
import pydrake.systems.framework
BallRpyJoint_: pydrake.common.cpp_template.TemplateClass
BodyFrame_: pydrake.common.cpp_template.TemplateClass
Body_: pydrake.common.cpp_template.TemplateClass
DoorHinge_: pydrake.common.cpp_template.TemplateClass
FixedOffsetFrame_: pydrake.common.cpp_template.TemplateClass
ForceElement_: pydrake.common.cpp_template.TemplateClass
Frame_: pydrake.common.cpp_template.TemplateClass
JointActuator_: pydrake.common.cpp_template.TemplateClass
Joint_: pydrake.common.cpp_template.TemplateClass
LinearBushingRollPitchYaw_: pydrake.common.cpp_template.TemplateClass
LinearSpringDamper_: pydrake.common.cpp_template.TemplateClass
MultibodyForces_: pydrake.common.cpp_template.TemplateClass
PlanarJoint_: pydrake.common.cpp_template.TemplateClass
PrismaticJoint_: pydrake.common.cpp_template.TemplateClass
PrismaticSpring_: pydrake.common.cpp_template.TemplateClass
QuaternionFloatingJoint_: pydrake.common.cpp_template.TemplateClass
RevoluteJoint_: pydrake.common.cpp_template.TemplateClass
RevoluteSpring_: pydrake.common.cpp_template.TemplateClass
RigidBody_: pydrake.common.cpp_template.TemplateClass
RotationalInertia_: pydrake.common.cpp_template.TemplateClass
ScrewJoint_: pydrake.common.cpp_template.TemplateClass
SpatialInertia_: pydrake.common.cpp_template.TemplateClass
UniformGravityFieldElement_: pydrake.common.cpp_template.TemplateClass
UnitInertia_: pydrake.common.cpp_template.TemplateClass
UniversalJoint_: pydrake.common.cpp_template.TemplateClass
WeldJoint_: pydrake.common.cpp_template.TemplateClass

class BallRpyJoint(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[3,1]]) -> BallRpyJoint_[float]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[float], w_FM: numpy.ndarray[numpy.float64[3,1]]) -> BallRpyJoint_[float]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[3,1]]) -> None: ...

class BallRpyJoint_[AutoDiffXd](Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[AutoDiffXd], angles: numpy.ndarray[object[3,1]]) -> BallRpyJoint_[AutoDiffXd]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], w_FM: numpy.ndarray[object[3,1]]) -> BallRpyJoint_[AutoDiffXd]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[3,1]]) -> None: ...

class BallRpyJoint_[Expression](Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[Expression], angles: numpy.ndarray[object[3,1]]) -> BallRpyJoint_[Expression]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression], w_FM: numpy.ndarray[object[3,1]]) -> BallRpyJoint_[Expression]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[3,1]]) -> None: ...

class BallRpyJoint_[float](Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[3,1]]) -> BallRpyJoint_[float]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[float], w_FM: numpy.ndarray[numpy.float64[3,1]]) -> BallRpyJoint_[float]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[3,1]]) -> None: ...

class Body:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInForce(self, context: pydrake.systems.framework.Context_[float], p_BP_E: numpy.ndarray[numpy.float64[3,1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[float], frame_E: Frame_[float], forces) -> None: ...
    def AddInForceInWorld(self, context: pydrake.systems.framework.Context_[float], F_Bo_W: pydrake.multibody.math.SpatialForce_[float], forces) -> None: ...
    def CalcCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def EvalPoseInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def EvalSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def EvalSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def GetForceInWorld(self, context: pydrake.systems.framework.Context_[float], forces) -> pydrake.multibody.math.SpatialForce_[float]: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def body_frame(self) -> BodyFrame_[float]: ...
    @overload
    def default_mass(self) -> float: ...
    @overload
    def default_mass(self) -> Any: ...
    def floating_position_suffix(self, arg0: int) -> str: ...
    def floating_positions_start(self) -> int: ...
    def floating_velocities_start(self) -> int: ...
    def floating_velocity_suffix(self, arg0: int) -> str: ...
    def get_mass(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_num_flexible_positions(self) -> int: ...
    def get_num_flexible_velocities(self) -> int: ...
    def has_quaternion_dofs(self) -> bool: ...
    def index(self) -> BodyIndex: ...
    def is_floating(self) -> bool: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[float]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class BodyFrame(Frame_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class BodyFrame_[AutoDiffXd](Frame_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class BodyFrame_[Expression](Frame_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class BodyFrame_[float](Frame_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class BodyIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: BodyIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: BodyIndex) -> bool: ...

class Body_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInForce(self, *args, **kwargs) -> Any: ...
    def AddInForceInWorld(self, *args, **kwargs) -> Any: ...
    def CalcCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def CalcSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def EvalPoseInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def EvalSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]: ...
    def EvalSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]: ...
    def GetForceInWorld(self, *args, **kwargs) -> Any: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    def body_frame(self) -> BodyFrame_[AutoDiffXd]: ...
    @overload
    def default_mass(self) -> float: ...
    @overload
    def default_mass(self) -> Any: ...
    def floating_position_suffix(self, arg0: int) -> str: ...
    def floating_positions_start(self) -> int: ...
    def floating_velocities_start(self) -> int: ...
    def floating_velocity_suffix(self, arg0: int) -> str: ...
    def get_mass(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_num_flexible_positions(self) -> int: ...
    def get_num_flexible_velocities(self) -> int: ...
    def has_quaternion_dofs(self) -> bool: ...
    def index(self) -> BodyIndex: ...
    def is_floating(self) -> bool: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class Body_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInForce(self, context: pydrake.systems.framework.Context_[Expression], p_BP_E: numpy.ndarray[object[3,1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[Expression], frame_E: Frame_[Expression], forces) -> None: ...
    def AddInForceInWorld(self, context: pydrake.systems.framework.Context_[Expression], F_Bo_W: pydrake.multibody.math.SpatialForce_[Expression], forces) -> None: ...
    def CalcCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def CalcSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def EvalPoseInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def EvalSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.multibody.math.SpatialAcceleration_[Expression]: ...
    def EvalSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.multibody.math.SpatialVelocity_[Expression]: ...
    def GetForceInWorld(self, context: pydrake.systems.framework.Context_[Expression], forces) -> pydrake.multibody.math.SpatialForce_[Expression]: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[Expression]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[Expression]) -> None: ...
    def body_frame(self) -> BodyFrame_[Expression]: ...
    @overload
    def default_mass(self) -> float: ...
    @overload
    def default_mass(self) -> Any: ...
    def floating_position_suffix(self, arg0: int) -> str: ...
    def floating_positions_start(self) -> int: ...
    def floating_velocities_start(self) -> int: ...
    def floating_velocity_suffix(self, arg0: int) -> str: ...
    def get_mass(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_num_flexible_positions(self) -> int: ...
    def get_num_flexible_velocities(self) -> int: ...
    def has_quaternion_dofs(self) -> bool: ...
    def index(self) -> BodyIndex: ...
    def is_floating(self) -> bool: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[Expression]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class Body_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInForce(self, context: pydrake.systems.framework.Context_[float], p_BP_E: numpy.ndarray[numpy.float64[3,1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[float], frame_E: Frame_[float], forces) -> None: ...
    def AddInForceInWorld(self, context: pydrake.systems.framework.Context_[float], F_Bo_W: pydrake.multibody.math.SpatialForce_[float], forces) -> None: ...
    def CalcCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def EvalPoseInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def EvalSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def EvalSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def GetForceInWorld(self, context: pydrake.systems.framework.Context_[float], forces) -> pydrake.multibody.math.SpatialForce_[float]: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def body_frame(self) -> BodyFrame_[float]: ...
    @overload
    def default_mass(self) -> float: ...
    @overload
    def default_mass(self) -> Any: ...
    def floating_position_suffix(self, arg0: int) -> str: ...
    def floating_positions_start(self) -> int: ...
    def floating_velocities_start(self) -> int: ...
    def floating_velocity_suffix(self, arg0: int) -> str: ...
    def get_mass(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_num_flexible_positions(self) -> int: ...
    def get_num_flexible_velocities(self) -> int: ...
    def has_quaternion_dofs(self) -> bool: ...
    def index(self) -> BodyIndex: ...
    def is_floating(self) -> bool: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[float]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class ConstraintIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: ConstraintIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: ConstraintIndex) -> bool: ...

class DoorHinge(ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[float], config: DoorHingeConfig) -> None: ...
    def CalcHingeFrictionalTorque(self, angular_rate: float) -> float: ...
    def CalcHingeSpringTorque(self, angle: float) -> float: ...
    def CalcHingeTorque(self, angle: float, angular_rate: float) -> float: ...
    def config(self) -> DoorHingeConfig: ...
    def joint(self) -> RevoluteJoint_[float]: ...

class DoorHingeConfig:
    __fields__: ClassVar[tuple] = ...  # read-only
    catch_torque: float
    catch_width: float
    dynamic_friction_torque: float
    motion_threshold: float
    spring_constant: float
    spring_zero_angle_rad: float
    static_friction_torque: float
    viscous_friction: float
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> DoorHingeConfig: ...
    def __deepcopy__(self, arg0: dict) -> DoorHingeConfig: ...

class DoorHinge_[AutoDiffXd](ForceElement_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[AutoDiffXd], config: DoorHingeConfig) -> None: ...
    def CalcHingeFrictionalTorque(self, angular_rate: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcHingeSpringTorque(self, angle: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcHingeTorque(self, angle: pydrake.autodiffutils.AutoDiffXd, angular_rate: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def config(self) -> DoorHingeConfig: ...
    def joint(self) -> RevoluteJoint_[AutoDiffXd]: ...

class DoorHinge_[Expression](ForceElement_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[Expression], config: DoorHingeConfig) -> None: ...
    def CalcHingeFrictionalTorque(self, angular_rate: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def CalcHingeSpringTorque(self, angle: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def CalcHingeTorque(self, angle: pydrake.symbolic.Expression, angular_rate: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def config(self) -> DoorHingeConfig: ...
    def joint(self) -> RevoluteJoint_[Expression]: ...

class DoorHinge_[float](ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[float], config: DoorHingeConfig) -> None: ...
    def CalcHingeFrictionalTorque(self, angular_rate: float) -> float: ...
    def CalcHingeSpringTorque(self, angle: float) -> float: ...
    def CalcHingeTorque(self, angle: float, angular_rate: float) -> float: ...
    def config(self) -> DoorHingeConfig: ...
    def joint(self) -> RevoluteJoint_[float]: ...

class FixedOffsetFrame(Frame_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, P: Frame_[float], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[ModelInstanceIndex] = ...) -> None: ...
    @overload
    def __init__(self, name: str, bodyB, X_BF: pydrake.math.RigidTransform_[float]) -> None: ...
    def GetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    @overload
    def SetPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[float], X_PF: pydrake.math.RigidTransform_[float]) -> None: ...
    @overload
    def SetPoseInBodyFrame(self) -> Any: ...
    def SetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[float], X_PF: pydrake.math.RigidTransform_[float]) -> None: ...

class FixedOffsetFrame_[AutoDiffXd](Frame_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, P: Frame_[AutoDiffXd], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[ModelInstanceIndex] = ...) -> None: ...
    def GetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    @overload
    def SetPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd], X_PF: pydrake.math.RigidTransform_[AutoDiffXd]) -> None: ...
    @overload
    def SetPoseInBodyFrame(self) -> Any: ...
    def SetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd], X_PF: pydrake.math.RigidTransform_[AutoDiffXd]) -> None: ...

class FixedOffsetFrame_[Expression](Frame_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, P: Frame_[Expression], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[ModelInstanceIndex] = ...) -> None: ...
    @overload
    def __init__(self, name: str, bodyB, X_BF: pydrake.math.RigidTransform_[float]) -> None: ...
    def GetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    @overload
    def SetPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[Expression], X_PF: pydrake.math.RigidTransform_[Expression]) -> None: ...
    @overload
    def SetPoseInBodyFrame(self) -> Any: ...
    def SetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[Expression], X_PF: pydrake.math.RigidTransform_[Expression]) -> None: ...

class FixedOffsetFrame_[float](Frame_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, P: Frame_[float], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[ModelInstanceIndex] = ...) -> None: ...
    @overload
    def __init__(self, name: str, bodyB, X_BF: pydrake.math.RigidTransform_[float]) -> None: ...
    def GetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    @overload
    def SetPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[float], X_PF: pydrake.math.RigidTransform_[float]) -> None: ...
    @overload
    def SetPoseInBodyFrame(self) -> Any: ...
    def SetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[float], X_PF: pydrake.math.RigidTransform_[float]) -> None: ...

class ForceElement:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def index(self) -> ForceElementIndex: ...
    def model_instance(self) -> ModelInstanceIndex: ...

class ForceElementIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: ForceElementIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: ForceElementIndex) -> bool: ...

class ForceElement_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def index(self) -> ForceElementIndex: ...
    def model_instance(self) -> ModelInstanceIndex: ...

class ForceElement_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def index(self) -> ForceElementIndex: ...
    def model_instance(self) -> ModelInstanceIndex: ...

class ForceElement_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def index(self) -> ForceElementIndex: ...
    def model_instance(self) -> ModelInstanceIndex: ...

class Frame:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def CalcAngularVelocity(self, context: pydrake.systems.framework.Context_[float], measured_in_frame: Frame_[float], expressed_in_frame: Frame_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcOffsetPoseInBody(self, context: pydrake.systems.framework.Context_[float], X_FQ: pydrake.math.RigidTransform_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcOffsetRotationMatrixInBody(self, context: pydrake.systems.framework.Context_[float], R_FQ: pydrake.math.RotationMatrix_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def CalcPose(self, context: pydrake.systems.framework.Context_[float], frame_M: Frame_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcPoseInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcRelativeSpatialAcceleration(self, context: pydrake.systems.framework.Context_[float], other_frame: Frame_[float], measured_in_frame: Frame_[float], expressed_in_frame: Frame_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcRelativeSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[float], other_frame: Frame_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcRelativeSpatialVelocity(self, context: pydrake.systems.framework.Context_[float], other_frame: Frame_[float], measured_in_frame: Frame_[float], expressed_in_frame: Frame_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def CalcRelativeSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[float], other_frame: Frame_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def CalcRotationMatrix(self, context: pydrake.systems.framework.Context_[float], frame_M: Frame_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def CalcRotationMatrixInBodyFrame(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def CalcRotationMatrixInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def CalcSpatialAcceleration(self, context: pydrake.systems.framework.Context_[float], measured_in_frame: Frame_[float], expressed_in_frame: Frame_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcSpatialVelocity(self, context: pydrake.systems.framework.Context_[float], frame_M: Frame_[float], frame_E: Frame_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def CalcSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def EvalAngularVelocityInWorld(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetFixedOffsetPoseInBody(self, X_FQ: pydrake.math.RigidTransform_[float]) -> pydrake.math.RigidTransform_[float]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[float]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[float]: ...
    def GetFixedRotationMatrixInBody(self, R_FQ: pydrake.math.RotationMatrix_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def GetFixedRotationMatrixInBodyFrame(self) -> pydrake.math.RotationMatrix_[float]: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def body(self, *args, **kwargs) -> Any: ...
    def index(self) -> FrameIndex: ...
    def is_body_frame(self) -> bool: ...
    def is_world_frame(self) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class FrameIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: FrameIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: FrameIndex) -> bool: ...

class Frame_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def CalcAngularVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], measured_in_frame: Frame_[AutoDiffXd], expressed_in_frame: Frame_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def CalcOffsetPoseInBody(self, context: pydrake.systems.framework.Context_[AutoDiffXd], X_FQ: pydrake.math.RigidTransform_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def CalcOffsetRotationMatrixInBody(self, context: pydrake.systems.framework.Context_[AutoDiffXd], R_FQ: pydrake.math.RotationMatrix_[AutoDiffXd]) -> pydrake.math.RotationMatrix_[AutoDiffXd]: ...
    def CalcPose(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_M: Frame_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def CalcPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def CalcPoseInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def CalcRelativeSpatialAcceleration(self, context: pydrake.systems.framework.Context_[AutoDiffXd], other_frame: Frame_[AutoDiffXd], measured_in_frame: Frame_[AutoDiffXd], expressed_in_frame: Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]: ...
    def CalcRelativeSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd], other_frame: Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]: ...
    def CalcRelativeSpatialVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], other_frame: Frame_[AutoDiffXd], measured_in_frame: Frame_[AutoDiffXd], expressed_in_frame: Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]: ...
    def CalcRelativeSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd], other_frame: Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]: ...
    def CalcRotationMatrix(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_M: Frame_[AutoDiffXd]) -> pydrake.math.RotationMatrix_[AutoDiffXd]: ...
    def CalcRotationMatrixInBodyFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RotationMatrix_[AutoDiffXd]: ...
    def CalcRotationMatrixInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RotationMatrix_[AutoDiffXd]: ...
    def CalcSpatialAcceleration(self, context: pydrake.systems.framework.Context_[AutoDiffXd], measured_in_frame: Frame_[AutoDiffXd], expressed_in_frame: Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]: ...
    def CalcSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]: ...
    def CalcSpatialVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_M: Frame_[AutoDiffXd], frame_E: Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]: ...
    def CalcSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]: ...
    def EvalAngularVelocityInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def GetFixedOffsetPoseInBody(self, X_FQ: pydrake.math.RigidTransform_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def GetFixedRotationMatrixInBody(self, R_FQ: pydrake.math.RotationMatrix_[AutoDiffXd]) -> pydrake.math.RotationMatrix_[AutoDiffXd]: ...
    def GetFixedRotationMatrixInBodyFrame(self) -> pydrake.math.RotationMatrix_[AutoDiffXd]: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def body(self, *args, **kwargs) -> Any: ...
    def index(self) -> FrameIndex: ...
    def is_body_frame(self) -> bool: ...
    def is_world_frame(self) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class Frame_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def CalcAngularVelocity(self, context: pydrake.systems.framework.Context_[Expression], measured_in_frame: Frame_[Expression], expressed_in_frame: Frame_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def CalcOffsetPoseInBody(self, context: pydrake.systems.framework.Context_[Expression], X_FQ: pydrake.math.RigidTransform_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def CalcOffsetRotationMatrixInBody(self, context: pydrake.systems.framework.Context_[Expression], R_FQ: pydrake.math.RotationMatrix_[Expression]) -> pydrake.math.RotationMatrix_[Expression]: ...
    def CalcPose(self, context: pydrake.systems.framework.Context_[Expression], frame_M: Frame_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def CalcPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def CalcPoseInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def CalcRelativeSpatialAcceleration(self, context: pydrake.systems.framework.Context_[Expression], other_frame: Frame_[Expression], measured_in_frame: Frame_[Expression], expressed_in_frame: Frame_[Expression]) -> pydrake.multibody.math.SpatialAcceleration_[Expression]: ...
    def CalcRelativeSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[Expression], other_frame: Frame_[Expression]) -> pydrake.multibody.math.SpatialAcceleration_[Expression]: ...
    def CalcRelativeSpatialVelocity(self, context: pydrake.systems.framework.Context_[Expression], other_frame: Frame_[Expression], measured_in_frame: Frame_[Expression], expressed_in_frame: Frame_[Expression]) -> pydrake.multibody.math.SpatialVelocity_[Expression]: ...
    def CalcRelativeSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[Expression], other_frame: Frame_[Expression]) -> pydrake.multibody.math.SpatialVelocity_[Expression]: ...
    def CalcRotationMatrix(self, context: pydrake.systems.framework.Context_[Expression], frame_M: Frame_[Expression]) -> pydrake.math.RotationMatrix_[Expression]: ...
    def CalcRotationMatrixInBodyFrame(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RotationMatrix_[Expression]: ...
    def CalcRotationMatrixInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RotationMatrix_[Expression]: ...
    def CalcSpatialAcceleration(self, context: pydrake.systems.framework.Context_[Expression], measured_in_frame: Frame_[Expression], expressed_in_frame: Frame_[Expression]) -> pydrake.multibody.math.SpatialAcceleration_[Expression]: ...
    def CalcSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.multibody.math.SpatialAcceleration_[Expression]: ...
    def CalcSpatialVelocity(self, context: pydrake.systems.framework.Context_[Expression], frame_M: Frame_[Expression], frame_E: Frame_[Expression]) -> pydrake.multibody.math.SpatialVelocity_[Expression]: ...
    def CalcSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.multibody.math.SpatialVelocity_[Expression]: ...
    def EvalAngularVelocityInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def GetFixedOffsetPoseInBody(self, X_FQ: pydrake.math.RigidTransform_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[Expression]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[Expression]: ...
    def GetFixedRotationMatrixInBody(self, R_FQ: pydrake.math.RotationMatrix_[Expression]) -> pydrake.math.RotationMatrix_[Expression]: ...
    def GetFixedRotationMatrixInBodyFrame(self) -> pydrake.math.RotationMatrix_[Expression]: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def body(self, *args, **kwargs) -> Any: ...
    def index(self) -> FrameIndex: ...
    def is_body_frame(self) -> bool: ...
    def is_world_frame(self) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class Frame_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def CalcAngularVelocity(self, context: pydrake.systems.framework.Context_[float], measured_in_frame: Frame_[float], expressed_in_frame: Frame_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcOffsetPoseInBody(self, context: pydrake.systems.framework.Context_[float], X_FQ: pydrake.math.RigidTransform_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcOffsetRotationMatrixInBody(self, context: pydrake.systems.framework.Context_[float], R_FQ: pydrake.math.RotationMatrix_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def CalcPose(self, context: pydrake.systems.framework.Context_[float], frame_M: Frame_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcPoseInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcRelativeSpatialAcceleration(self, context: pydrake.systems.framework.Context_[float], other_frame: Frame_[float], measured_in_frame: Frame_[float], expressed_in_frame: Frame_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcRelativeSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[float], other_frame: Frame_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcRelativeSpatialVelocity(self, context: pydrake.systems.framework.Context_[float], other_frame: Frame_[float], measured_in_frame: Frame_[float], expressed_in_frame: Frame_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def CalcRelativeSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[float], other_frame: Frame_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def CalcRotationMatrix(self, context: pydrake.systems.framework.Context_[float], frame_M: Frame_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def CalcRotationMatrixInBodyFrame(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def CalcRotationMatrixInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def CalcSpatialAcceleration(self, context: pydrake.systems.framework.Context_[float], measured_in_frame: Frame_[float], expressed_in_frame: Frame_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcSpatialVelocity(self, context: pydrake.systems.framework.Context_[float], frame_M: Frame_[float], frame_E: Frame_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def CalcSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def EvalAngularVelocityInWorld(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetFixedOffsetPoseInBody(self, X_FQ: pydrake.math.RigidTransform_[float]) -> pydrake.math.RigidTransform_[float]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[float]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[float]: ...
    def GetFixedRotationMatrixInBody(self, R_FQ: pydrake.math.RotationMatrix_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def GetFixedRotationMatrixInBodyFrame(self) -> pydrake.math.RotationMatrix_[float]: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def body(self, *args, **kwargs) -> Any: ...
    def index(self) -> FrameIndex: ...
    def is_body_frame(self) -> bool: ...
    def is_world_frame(self) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class JacobianWrtVariable:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kQDot: ClassVar[JacobianWrtVariable] = ...
    kV: ClassVar[JacobianWrtVariable] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Joint:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInDamping(self, context: pydrake.systems.framework.Context_[float], forces) -> None: ...
    def AddInOneForce(self, context: pydrake.systems.framework.Context_[float], joint_dof: int, joint_tau: float, forces) -> None: ...
    def GetOnePosition(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def GetOneVelocity(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def acceleration_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def acceleration_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def child_body(self) -> Body_[float]: ...
    def default_positions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def frame_on_child(self) -> Frame_[float]: ...
    def frame_on_parent(self) -> Frame_[float]: ...
    def index(self) -> JointIndex: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[float]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_positions(self) -> int: ...
    def num_velocities(self) -> int: ...
    def parent_body(self) -> Body_[float]: ...
    def position_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def position_start(self) -> int: ...
    def position_suffix(self, arg0: int) -> str: ...
    def position_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def set_acceleration_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_default_positions(self, default_positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_position_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_velocity_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def type_name(self) -> str: ...
    def velocity_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def velocity_start(self) -> int: ...
    def velocity_suffix(self, arg0: int) -> str: ...
    def velocity_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...

class JointActuator:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def effort_limit(self) -> float: ...
    def get_actuation_vector(self, u: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def index(self) -> JointActuatorIndex: ...
    def input_start(self) -> int: ...
    def joint(self) -> Joint_[float]: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_inputs(self) -> int: ...
    def set_actuation_vector(self, u_instance: numpy.ndarray[numpy.float64[m,1]], u: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...

class JointActuatorIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: JointActuatorIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: JointActuatorIndex) -> bool: ...

class JointActuator_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def effort_limit(self) -> float: ...
    def get_actuation_vector(self, u: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def index(self) -> JointActuatorIndex: ...
    def input_start(self) -> int: ...
    def joint(self) -> Joint_[AutoDiffXd]: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_inputs(self) -> int: ...
    def set_actuation_vector(self, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...

class JointActuator_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def effort_limit(self) -> float: ...
    def get_actuation_vector(self, u: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def index(self) -> JointActuatorIndex: ...
    def input_start(self) -> int: ...
    def joint(self) -> Joint_[Expression]: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_inputs(self) -> int: ...
    def set_actuation_vector(self, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...

class JointActuator_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def effort_limit(self) -> float: ...
    def get_actuation_vector(self, u: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def index(self) -> JointActuatorIndex: ...
    def input_start(self) -> int: ...
    def joint(self) -> Joint_[float]: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_inputs(self) -> int: ...
    def set_actuation_vector(self, u_instance: numpy.ndarray[numpy.float64[m,1]], u: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...

class JointIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: JointIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: JointIndex) -> bool: ...

class Joint_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInDamping(self, *args, **kwargs) -> Any: ...
    def AddInOneForce(self, *args, **kwargs) -> Any: ...
    def GetOnePosition(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def GetOneVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    def acceleration_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def acceleration_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def child_body(self) -> Body_[AutoDiffXd]: ...
    def default_positions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def frame_on_child(self) -> Frame_[AutoDiffXd]: ...
    def frame_on_parent(self) -> Frame_[AutoDiffXd]: ...
    def index(self) -> JointIndex: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_positions(self) -> int: ...
    def num_velocities(self) -> int: ...
    def parent_body(self) -> Body_[AutoDiffXd]: ...
    def position_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def position_start(self) -> int: ...
    def position_suffix(self, arg0: int) -> str: ...
    def position_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def set_acceleration_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_default_positions(self, default_positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_position_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_velocity_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def type_name(self) -> str: ...
    def velocity_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def velocity_start(self) -> int: ...
    def velocity_suffix(self, arg0: int) -> str: ...
    def velocity_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...

class Joint_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInDamping(self, context: pydrake.systems.framework.Context_[Expression], forces) -> None: ...
    def AddInOneForce(self, context: pydrake.systems.framework.Context_[Expression], joint_dof: int, joint_tau: pydrake.symbolic.Expression, forces) -> None: ...
    def GetOnePosition(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def GetOneVelocity(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[Expression]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[Expression]) -> None: ...
    def acceleration_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def acceleration_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def child_body(self) -> Body_[Expression]: ...
    def default_positions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def frame_on_child(self) -> Frame_[Expression]: ...
    def frame_on_parent(self) -> Frame_[Expression]: ...
    def index(self) -> JointIndex: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[Expression]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_positions(self) -> int: ...
    def num_velocities(self) -> int: ...
    def parent_body(self) -> Body_[Expression]: ...
    def position_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def position_start(self) -> int: ...
    def position_suffix(self, arg0: int) -> str: ...
    def position_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def set_acceleration_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_default_positions(self, default_positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_position_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_velocity_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def type_name(self) -> str: ...
    def velocity_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def velocity_start(self) -> int: ...
    def velocity_suffix(self, arg0: int) -> str: ...
    def velocity_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...

class Joint_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInDamping(self, context: pydrake.systems.framework.Context_[float], forces) -> None: ...
    def AddInOneForce(self, context: pydrake.systems.framework.Context_[float], joint_dof: int, joint_tau: float, forces) -> None: ...
    def GetOnePosition(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def GetOneVelocity(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def acceleration_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def acceleration_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def child_body(self) -> Body_[float]: ...
    def default_positions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def frame_on_child(self) -> Frame_[float]: ...
    def frame_on_parent(self) -> Frame_[float]: ...
    def index(self) -> JointIndex: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[float]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_positions(self) -> int: ...
    def num_velocities(self) -> int: ...
    def parent_body(self) -> Body_[float]: ...
    def position_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def position_start(self) -> int: ...
    def position_suffix(self, arg0: int) -> str: ...
    def position_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def set_acceleration_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_default_positions(self, default_positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_position_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_velocity_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def type_name(self) -> str: ...
    def velocity_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def velocity_start(self) -> int: ...
    def velocity_suffix(self, arg0: int) -> str: ...
    def velocity_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...

class LinearBushingRollPitchYaw(ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, frameA: Frame_[float], frameC: Frame_[float], torque_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], torque_damping_constants: numpy.ndarray[numpy.float64[3,1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], force_damping_constants: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcBushingSpatialForceOnFrameA(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialForce_[float]: ...
    def CalcBushingSpatialForceOnFrameC(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialForce_[float]: ...
    def GetForceDampingConstants(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def SetForceDampingConstants(self, context: pydrake.systems.framework.Context_[float], force_damping: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[float], force_stiffness: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[float], torque_damping: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[float], torque_stiffness: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def force_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def force_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def frameA(self) -> Frame_[float]: ...
    def frameC(self) -> Frame_[float]: ...
    def link0(self) -> Body_[float]: ...
    def link1(self) -> Body_[float]: ...
    def torque_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def torque_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class LinearBushingRollPitchYaw_[AutoDiffXd](ForceElement_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, frameA: Frame_[AutoDiffXd], frameC: Frame_[AutoDiffXd], torque_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], torque_damping_constants: numpy.ndarray[numpy.float64[3,1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], force_damping_constants: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcBushingSpatialForceOnFrameA(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.multibody.math.SpatialForce_[AutoDiffXd]: ...
    def CalcBushingSpatialForceOnFrameC(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.multibody.math.SpatialForce_[AutoDiffXd]: ...
    def GetForceDampingConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def GetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def SetForceDampingConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd], force_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd], force_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd], torque_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd], torque_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def force_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def force_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def frameA(self) -> Frame_[AutoDiffXd]: ...
    def frameC(self) -> Frame_[AutoDiffXd]: ...
    def link0(self) -> Body_[AutoDiffXd]: ...
    def link1(self) -> Body_[AutoDiffXd]: ...
    def torque_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def torque_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class LinearBushingRollPitchYaw_[Expression](ForceElement_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, frameA: Frame_[Expression], frameC: Frame_[Expression], torque_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], torque_damping_constants: numpy.ndarray[numpy.float64[3,1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], force_damping_constants: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcBushingSpatialForceOnFrameA(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.multibody.math.SpatialForce_[Expression]: ...
    def CalcBushingSpatialForceOnFrameC(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.multibody.math.SpatialForce_[Expression]: ...
    def GetForceDampingConstants(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def GetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def SetForceDampingConstants(self, context: pydrake.systems.framework.Context_[Expression], force_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[Expression], force_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[Expression], torque_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[Expression], torque_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def force_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def force_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def frameA(self) -> Frame_[Expression]: ...
    def frameC(self) -> Frame_[Expression]: ...
    def link0(self) -> Body_[Expression]: ...
    def link1(self) -> Body_[Expression]: ...
    def torque_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def torque_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class LinearBushingRollPitchYaw_[float](ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, frameA: Frame_[float], frameC: Frame_[float], torque_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], torque_damping_constants: numpy.ndarray[numpy.float64[3,1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], force_damping_constants: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcBushingSpatialForceOnFrameA(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialForce_[float]: ...
    def CalcBushingSpatialForceOnFrameC(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialForce_[float]: ...
    def GetForceDampingConstants(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def SetForceDampingConstants(self, context: pydrake.systems.framework.Context_[float], force_damping: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[float], force_stiffness: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[float], torque_damping: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[float], torque_stiffness: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def force_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def force_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def frameA(self) -> Frame_[float]: ...
    def frameC(self) -> Frame_[float]: ...
    def link0(self) -> Body_[float]: ...
    def link1(self) -> Body_[float]: ...
    def torque_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def torque_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class LinearSpringDamper(ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA: Body_[float], p_AP: numpy.ndarray[numpy.float64[3,1]], bodyB: Body_[float], p_BQ: numpy.ndarray[numpy.float64[3,1]], free_length: float, stiffness: float, damping: float) -> None: ...
    def bodyA(self) -> Body_[float]: ...
    def bodyB(self) -> Body_[float]: ...
    def damping(self) -> float: ...
    def free_length(self) -> float: ...
    def p_AP(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def p_BQ(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def stiffness(self) -> float: ...

class LinearSpringDamper_[AutoDiffXd](ForceElement_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA: Body_[AutoDiffXd], p_AP: numpy.ndarray[numpy.float64[3,1]], bodyB: Body_[AutoDiffXd], p_BQ: numpy.ndarray[numpy.float64[3,1]], free_length: float, stiffness: float, damping: float) -> None: ...
    def bodyA(self) -> Body_[AutoDiffXd]: ...
    def bodyB(self) -> Body_[AutoDiffXd]: ...
    def damping(self) -> float: ...
    def free_length(self) -> float: ...
    def p_AP(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def p_BQ(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def stiffness(self) -> float: ...

class LinearSpringDamper_[Expression](ForceElement_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA: Body_[Expression], p_AP: numpy.ndarray[numpy.float64[3,1]], bodyB: Body_[Expression], p_BQ: numpy.ndarray[numpy.float64[3,1]], free_length: float, stiffness: float, damping: float) -> None: ...
    def bodyA(self) -> Body_[Expression]: ...
    def bodyB(self) -> Body_[Expression]: ...
    def damping(self) -> float: ...
    def free_length(self) -> float: ...
    def p_AP(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def p_BQ(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def stiffness(self) -> float: ...

class LinearSpringDamper_[float](ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA: Body_[float], p_AP: numpy.ndarray[numpy.float64[3,1]], bodyB: Body_[float], p_BQ: numpy.ndarray[numpy.float64[3,1]], free_length: float, stiffness: float, damping: float) -> None: ...
    def bodyA(self) -> Body_[float]: ...
    def bodyB(self) -> Body_[float]: ...
    def damping(self) -> float: ...
    def free_length(self) -> float: ...
    def p_AP(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def p_BQ(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def stiffness(self) -> float: ...

class ModelInstanceIndex:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def is_valid(self) -> bool: ...
    @overload
    def __eq__(self, arg0: ModelInstanceIndex) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __lt__(self, arg0: ModelInstanceIndex) -> bool: ...

class MultibodyForces:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, plant) -> None: ...
    @overload
    def __init__(self, nb: int, nv: int) -> None: ...
    def AddInForces(self, addend: MultibodyForces_[float]) -> None: ...
    def SetZero(self) -> MultibodyForces_[float]: ...
    def generalized_forces(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def mutable_generalized_forces(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def num_bodies(self) -> int: ...
    def num_velocities(self) -> int: ...
    def __copy__(self) -> MultibodyForces_[float]: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyForces_[float]: ...

class MultibodyForces_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, nb: int, nv: int) -> None: ...
    def AddInForces(self, addend: MultibodyForces_[AutoDiffXd]) -> None: ...
    def SetZero(self) -> MultibodyForces_[AutoDiffXd]: ...
    def generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def mutable_generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def num_bodies(self) -> int: ...
    def num_velocities(self) -> int: ...
    def __copy__(self) -> MultibodyForces_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyForces_[AutoDiffXd]: ...

class MultibodyForces_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, plant) -> None: ...
    @overload
    def __init__(self, nb: int, nv: int) -> None: ...
    def AddInForces(self, addend: MultibodyForces_[Expression]) -> None: ...
    def SetZero(self) -> MultibodyForces_[Expression]: ...
    def generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def mutable_generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def num_bodies(self) -> int: ...
    def num_velocities(self) -> int: ...
    def __copy__(self) -> MultibodyForces_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyForces_[Expression]: ...

class MultibodyForces_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, plant) -> None: ...
    @overload
    def __init__(self, nb: int, nv: int) -> None: ...
    def AddInForces(self, addend: MultibodyForces_[float]) -> None: ...
    def SetZero(self) -> MultibodyForces_[float]: ...
    def generalized_forces(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def mutable_generalized_forces(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def num_bodies(self) -> int: ...
    def num_velocities(self) -> int: ...
    def __copy__(self) -> MultibodyForces_[float]: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyForces_[float]: ...

class PlanarJoint(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], damping: numpy.ndarray[numpy.float64[3,1]] = ...) -> None: ...
    def damping(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[float], theta_dot: float) -> PlanarJoint_[float]: ...
    def set_default_pose(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> None: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> PlanarJoint_[float]: ...
    def set_random_pose_distribution(self, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> None: ...
    def set_rotation(self, context: pydrake.systems.framework.Context_[float], theta: float) -> PlanarJoint_[float]: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> PlanarJoint_[float]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[float], v_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> PlanarJoint_[float]: ...

class PlanarJoint_[AutoDiffXd](Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], damping: numpy.ndarray[numpy.float64[3,1]] = ...) -> None: ...
    def damping(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[2,1]]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[2,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], theta_dot: pydrake.autodiffutils.AutoDiffXd) -> PlanarJoint_[AutoDiffXd]: ...
    def set_default_pose(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> None: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[AutoDiffXd], p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.autodiffutils.AutoDiffXd) -> PlanarJoint_[AutoDiffXd]: ...
    def set_random_pose_distribution(self, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> None: ...
    def set_rotation(self, context: pydrake.systems.framework.Context_[AutoDiffXd], theta: pydrake.autodiffutils.AutoDiffXd) -> PlanarJoint_[AutoDiffXd]: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[AutoDiffXd], p_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_[AutoDiffXd]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], v_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_[AutoDiffXd]: ...

class PlanarJoint_[Expression](Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], damping: numpy.ndarray[numpy.float64[3,1]] = ...) -> None: ...
    def damping(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[2,1]]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[2,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression], theta_dot: pydrake.symbolic.Expression) -> PlanarJoint_[Expression]: ...
    def set_default_pose(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> None: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[Expression], p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> PlanarJoint_[Expression]: ...
    def set_random_pose_distribution(self, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> None: ...
    def set_rotation(self, context: pydrake.systems.framework.Context_[Expression], theta: pydrake.symbolic.Expression) -> PlanarJoint_[Expression]: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[Expression], p_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_[Expression]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[Expression], v_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_[Expression]: ...

class PlanarJoint_[float](Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], damping: numpy.ndarray[numpy.float64[3,1]] = ...) -> None: ...
    def damping(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[float], theta_dot: float) -> PlanarJoint_[float]: ...
    def set_default_pose(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> None: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> PlanarJoint_[float]: ...
    def set_random_pose_distribution(self, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> None: ...
    def set_rotation(self, context: pydrake.systems.framework.Context_[float], theta: float) -> PlanarJoint_[float]: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> PlanarJoint_[float]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[float], v_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> PlanarJoint_[float]: ...

class PrismaticJoint(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float = ..., pos_upper_limit: float = ..., damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_translation_rate(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def set_default_translation(self, translation: float) -> None: ...
    def set_random_translation_distribution(self, translation: pydrake.symbolic.Expression) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[float], translation: float) -> PrismaticJoint_[float]: ...
    def set_translation_rate(self, context: pydrake.systems.framework.Context_[float], translation_dot: float) -> PrismaticJoint_[float]: ...
    def translation_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class PrismaticJoint_[AutoDiffXd](Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float = ..., pos_upper_limit: float = ..., damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translation_rate(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def set_default_translation(self, translation: float) -> None: ...
    def set_random_translation_distribution(self, translation: pydrake.symbolic.Expression) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[AutoDiffXd], translation: pydrake.autodiffutils.AutoDiffXd) -> PrismaticJoint_[AutoDiffXd]: ...
    def set_translation_rate(self, context: pydrake.systems.framework.Context_[AutoDiffXd], translation_dot: pydrake.autodiffutils.AutoDiffXd) -> PrismaticJoint_[AutoDiffXd]: ...
    def translation_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class PrismaticJoint_[Expression](Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float = ..., pos_upper_limit: float = ..., damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_translation_rate(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def set_default_translation(self, translation: float) -> None: ...
    def set_random_translation_distribution(self, translation: pydrake.symbolic.Expression) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[Expression], translation: pydrake.symbolic.Expression) -> PrismaticJoint_[Expression]: ...
    def set_translation_rate(self, context: pydrake.systems.framework.Context_[Expression], translation_dot: pydrake.symbolic.Expression) -> PrismaticJoint_[Expression]: ...
    def translation_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class PrismaticJoint_[float](Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float = ..., pos_upper_limit: float = ..., damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_translation_rate(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def set_default_translation(self, translation: float) -> None: ...
    def set_random_translation_distribution(self, translation: pydrake.symbolic.Expression) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[float], translation: float) -> PrismaticJoint_[float]: ...
    def set_translation_rate(self, context: pydrake.systems.framework.Context_[float], translation_dot: float) -> PrismaticJoint_[float]: ...
    def translation_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class PrismaticSpring(ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: PrismaticJoint_[float], nominal_position: float, stiffness: float) -> None: ...
    def joint(self) -> PrismaticJoint_[float]: ...
    def nominal_position(self) -> float: ...
    def stiffness(self) -> float: ...

class PrismaticSpring_[AutoDiffXd](ForceElement_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: PrismaticJoint_[AutoDiffXd], nominal_position: float, stiffness: float) -> None: ...
    def joint(self) -> PrismaticJoint_[AutoDiffXd]: ...
    def nominal_position(self) -> float: ...
    def stiffness(self) -> float: ...

class PrismaticSpring_[Expression](ForceElement_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: PrismaticJoint_[Expression], nominal_position: float, stiffness: float) -> None: ...
    def joint(self) -> PrismaticJoint_[Expression]: ...
    def nominal_position(self) -> float: ...
    def stiffness(self) -> float: ...

class PrismaticSpring_[float](ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: PrismaticJoint_[float], nominal_position: float, stiffness: float) -> None: ...
    def joint(self) -> PrismaticJoint_[float]: ...
    def nominal_position(self) -> float: ...
    def stiffness(self) -> float: ...

class QuaternionFloatingJoint(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], angular_damping: float = ..., translational_damping: float = ...) -> None: ...
    def SetDefaultPose(self, X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def SetFromRotationMatrix(self, context: pydrake.systems.framework.Context_[float], R_FM: pydrake.math.RotationMatrix_[float]) -> QuaternionFloatingJoint_[float]: ...
    def angular_damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_pose(self) -> pydrake.math.RigidTransform_[float]: ...
    def get_default_position(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_quaternion(self) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def get_pose(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def get_position(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_quaternion(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[float], w_FM: numpy.ndarray[numpy.float64[3,1]]) -> QuaternionFloatingJoint_[float]: ...
    def set_default_position(self, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_default_quaternion(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[float]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[float], X_FM: pydrake.math.RigidTransform_[float]) -> QuaternionFloatingJoint_[float]: ...
    def set_position(self, context: pydrake.systems.framework.Context_[float], p_FM: numpy.ndarray[numpy.float64[3,1]]) -> QuaternionFloatingJoint_[float]: ...
    def set_quaternion(self, context: pydrake.systems.framework.Context_[float], q_FM: pydrake.common.eigen_geometry.Quaternion_[float]) -> QuaternionFloatingJoint_[float]: ...
    def set_random_position_distribution(self, p_FM: numpy.ndarray[object[3,1]]) -> None: ...
    def set_random_quaternion_distribution(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[Expression]) -> None: ...
    def set_random_quaternion_distribution_to_uniform(self) -> None: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[float], v_FM: numpy.ndarray[numpy.float64[3,1]]) -> QuaternionFloatingJoint_[float]: ...
    def translational_damping(self) -> float: ...

class QuaternionFloatingJoint_[AutoDiffXd](Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], angular_damping: float = ..., translational_damping: float = ...) -> None: ...
    def SetDefaultPose(self, X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def SetFromRotationMatrix(self, context: pydrake.systems.framework.Context_[AutoDiffXd], R_FM: pydrake.math.RotationMatrix_[AutoDiffXd]) -> QuaternionFloatingJoint_[AutoDiffXd]: ...
    def angular_damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def get_default_pose(self) -> pydrake.math.RigidTransform_[float]: ...
    def get_default_position(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_quaternion(self) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def get_pose(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def get_position(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def get_quaternion(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], w_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_[AutoDiffXd]: ...
    def set_default_position(self, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_default_quaternion(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[float]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[AutoDiffXd], X_FM: pydrake.math.RigidTransform_[AutoDiffXd]) -> QuaternionFloatingJoint_[AutoDiffXd]: ...
    def set_position(self, context: pydrake.systems.framework.Context_[AutoDiffXd], p_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_[AutoDiffXd]: ...
    def set_quaternion(self, context: pydrake.systems.framework.Context_[AutoDiffXd], q_FM: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -> QuaternionFloatingJoint_[AutoDiffXd]: ...
    def set_random_position_distribution(self, p_FM: numpy.ndarray[object[3,1]]) -> None: ...
    def set_random_quaternion_distribution(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[Expression]) -> None: ...
    def set_random_quaternion_distribution_to_uniform(self) -> None: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], v_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_[AutoDiffXd]: ...
    def translational_damping(self) -> float: ...

class QuaternionFloatingJoint_[Expression](Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], angular_damping: float = ..., translational_damping: float = ...) -> None: ...
    def SetDefaultPose(self, X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def SetFromRotationMatrix(self, context: pydrake.systems.framework.Context_[Expression], R_FM: pydrake.math.RotationMatrix_[Expression]) -> QuaternionFloatingJoint_[Expression]: ...
    def angular_damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def get_default_pose(self) -> pydrake.math.RigidTransform_[float]: ...
    def get_default_position(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_quaternion(self) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def get_pose(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def get_position(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def get_quaternion(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.common.eigen_geometry.Quaternion_[Expression]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression], w_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_[Expression]: ...
    def set_default_position(self, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_default_quaternion(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[float]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[Expression], X_FM: pydrake.math.RigidTransform_[Expression]) -> QuaternionFloatingJoint_[Expression]: ...
    def set_position(self, context: pydrake.systems.framework.Context_[Expression], p_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_[Expression]: ...
    def set_quaternion(self, context: pydrake.systems.framework.Context_[Expression], q_FM: pydrake.common.eigen_geometry.Quaternion_[Expression]) -> QuaternionFloatingJoint_[Expression]: ...
    def set_random_position_distribution(self, p_FM: numpy.ndarray[object[3,1]]) -> None: ...
    def set_random_quaternion_distribution(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[Expression]) -> None: ...
    def set_random_quaternion_distribution_to_uniform(self) -> None: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[Expression], v_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_[Expression]: ...
    def translational_damping(self) -> float: ...

class QuaternionFloatingJoint_[float](Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], angular_damping: float = ..., translational_damping: float = ...) -> None: ...
    def SetDefaultPose(self, X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def SetFromRotationMatrix(self, context: pydrake.systems.framework.Context_[float], R_FM: pydrake.math.RotationMatrix_[float]) -> QuaternionFloatingJoint_[float]: ...
    def angular_damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_pose(self) -> pydrake.math.RigidTransform_[float]: ...
    def get_default_position(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_quaternion(self) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def get_pose(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def get_position(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_quaternion(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[float], w_FM: numpy.ndarray[numpy.float64[3,1]]) -> QuaternionFloatingJoint_[float]: ...
    def set_default_position(self, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_default_quaternion(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[float]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[float], X_FM: pydrake.math.RigidTransform_[float]) -> QuaternionFloatingJoint_[float]: ...
    def set_position(self, context: pydrake.systems.framework.Context_[float], p_FM: numpy.ndarray[numpy.float64[3,1]]) -> QuaternionFloatingJoint_[float]: ...
    def set_quaternion(self, context: pydrake.systems.framework.Context_[float], q_FM: pydrake.common.eigen_geometry.Quaternion_[float]) -> QuaternionFloatingJoint_[float]: ...
    def set_random_position_distribution(self, p_FM: numpy.ndarray[object[3,1]]) -> None: ...
    def set_random_quaternion_distribution(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[Expression]) -> None: ...
    def set_random_quaternion_distribution_to_uniform(self) -> None: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[float], v_FM: numpy.ndarray[numpy.float64[3,1]]) -> QuaternionFloatingJoint_[float]: ...
    def translational_damping(self) -> float: ...

class RevoluteJoint(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], axis: numpy.ndarray[numpy.float64[3,1]], damping: float = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_angle(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_angular_rate(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_default_angle(self) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def revolute_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angle(self, context: pydrake.systems.framework.Context_[float], angle: float) -> RevoluteJoint_[float]: ...
    def set_angular_rate(self, context: pydrake.systems.framework.Context_[float], angle: float) -> RevoluteJoint_[float]: ...
    def set_default_angle(self, angle: float) -> None: ...
    def set_random_angle_distribution(self, angle: pydrake.symbolic.Expression) -> None: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class RevoluteJoint_[AutoDiffXd](Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3,1]], damping: float = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_angle(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_angular_rate(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_default_angle(self) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def revolute_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angle(self, context: pydrake.systems.framework.Context_[AutoDiffXd], angle: pydrake.autodiffutils.AutoDiffXd) -> RevoluteJoint_[AutoDiffXd]: ...
    def set_angular_rate(self, context: pydrake.systems.framework.Context_[AutoDiffXd], angle: pydrake.autodiffutils.AutoDiffXd) -> RevoluteJoint_[AutoDiffXd]: ...
    def set_default_angle(self, angle: float) -> None: ...
    def set_random_angle_distribution(self, angle: pydrake.symbolic.Expression) -> None: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class RevoluteJoint_[Expression](Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], axis: numpy.ndarray[numpy.float64[3,1]], damping: float = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_angle(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_angular_rate(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_default_angle(self) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def revolute_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angle(self, context: pydrake.systems.framework.Context_[Expression], angle: pydrake.symbolic.Expression) -> RevoluteJoint_[Expression]: ...
    def set_angular_rate(self, context: pydrake.systems.framework.Context_[Expression], angle: pydrake.symbolic.Expression) -> RevoluteJoint_[Expression]: ...
    def set_default_angle(self, angle: float) -> None: ...
    def set_random_angle_distribution(self, angle: pydrake.symbolic.Expression) -> None: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class RevoluteJoint_[float](Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], axis: numpy.ndarray[numpy.float64[3,1]], damping: float = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_angle(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_angular_rate(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_default_angle(self) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def revolute_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angle(self, context: pydrake.systems.framework.Context_[float], angle: float) -> RevoluteJoint_[float]: ...
    def set_angular_rate(self, context: pydrake.systems.framework.Context_[float], angle: float) -> RevoluteJoint_[float]: ...
    def set_default_angle(self, angle: float) -> None: ...
    def set_random_angle_distribution(self, angle: pydrake.symbolic.Expression) -> None: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class RevoluteSpring(ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[float], nominal_angle: float, stiffness: float) -> None: ...
    def joint(self) -> RevoluteJoint_[float]: ...
    def nominal_angle(self) -> float: ...
    def stiffness(self) -> float: ...

class RevoluteSpring_[AutoDiffXd](ForceElement_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[AutoDiffXd], nominal_angle: float, stiffness: float) -> None: ...
    def joint(self) -> RevoluteJoint_[AutoDiffXd]: ...
    def nominal_angle(self) -> float: ...
    def stiffness(self) -> float: ...

class RevoluteSpring_[Expression](ForceElement_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[Expression], nominal_angle: float, stiffness: float) -> None: ...
    def joint(self) -> RevoluteJoint_[Expression]: ...
    def nominal_angle(self) -> float: ...
    def stiffness(self) -> float: ...

class RevoluteSpring_[float](ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[float], nominal_angle: float, stiffness: float) -> None: ...
    def joint(self) -> RevoluteJoint_[float]: ...
    def nominal_angle(self) -> float: ...
    def stiffness(self) -> float: ...

class RigidBody(Body_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_name: str, M_BBo_B) -> None: ...
    @overload
    def __init__(self, body_name: str, model_instance: ModelInstanceIndex, M_BBo_B) -> None: ...
    def SetCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[float], com: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetMass(self, context: pydrake.systems.framework.Context_[float], mass: float) -> None: ...
    def SetSpatialInertiaInBodyFrame(self, context: pydrake.systems.framework.Context_[float], M_Bo_B) -> None: ...
    def default_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def default_mass(self) -> float: ...
    def default_rotational_inertia(self, *args, **kwargs) -> Any: ...
    def default_spatial_inertia(self, *args, **kwargs) -> Any: ...
    def default_unit_inertia(self, *args, **kwargs) -> Any: ...

class RigidBody_[AutoDiffXd](Body_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_name: str, M_BBo_B: SpatialInertia_[float]) -> None: ...
    @overload
    def __init__(self, body_name: str, model_instance: ModelInstanceIndex, M_BBo_B: SpatialInertia_[float]) -> None: ...
    def SetCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd], com: numpy.ndarray[object[3,1]]) -> None: ...
    def SetMass(self, context: pydrake.systems.framework.Context_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def SetSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def default_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def default_mass(self) -> float: ...
    def default_rotational_inertia(self) -> RotationalInertia_[float]: ...
    def default_spatial_inertia(self) -> SpatialInertia_[float]: ...
    def default_unit_inertia(self) -> UnitInertia_[float]: ...

class RigidBody_[Expression](Body_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_name: str, M_BBo_B: SpatialInertia_[float]) -> None: ...
    @overload
    def __init__(self, body_name: str, model_instance: ModelInstanceIndex, M_BBo_B: SpatialInertia_[float]) -> None: ...
    def SetCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[Expression], com: numpy.ndarray[object[3,1]]) -> None: ...
    def SetMass(self, context: pydrake.systems.framework.Context_[Expression], mass: pydrake.symbolic.Expression) -> None: ...
    def SetSpatialInertiaInBodyFrame(self, context: pydrake.systems.framework.Context_[Expression], M_Bo_B) -> None: ...
    def default_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def default_mass(self) -> float: ...
    def default_rotational_inertia(self) -> RotationalInertia_[float]: ...
    def default_spatial_inertia(self) -> SpatialInertia_[float]: ...
    def default_unit_inertia(self) -> UnitInertia_[float]: ...

class RigidBody_[float](Body_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_name: str, M_BBo_B) -> None: ...
    @overload
    def __init__(self, body_name: str, model_instance: ModelInstanceIndex, M_BBo_B) -> None: ...
    def SetCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[float], com: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetMass(self, context: pydrake.systems.framework.Context_[float], mass: float) -> None: ...
    def SetSpatialInertiaInBodyFrame(self, context: pydrake.systems.framework.Context_[float], M_Bo_B) -> None: ...
    def default_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def default_mass(self) -> float: ...
    def default_rotational_inertia(self, *args, **kwargs) -> Any: ...
    def default_spatial_inertia(self, *args, **kwargs) -> Any: ...
    def default_unit_inertia(self, *args, **kwargs) -> Any: ...

class RotationalInertia:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None: ...
    @overload
    def __init__(self, mass: float, p_PQ_E: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcMaximumPossibleMomentOfInertia(self) -> float: ...
    def CalcPrincipalMomentsOfInertia(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CopyToFullMatrix3(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    @overload
    def CouldBePhysicallyValid(self) -> bool: ...
    @overload
    def CouldBePhysicallyValid(self) -> Any: ...
    def IsNaN(self) -> bool: ...
    def IsNearlyEqualTo(self, other: RotationalInertia_[float], precision: float) -> bool: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[float]) -> RotationalInertia_[float]: ...
    def SetToNaN(self) -> None: ...
    def SetZero(self) -> None: ...
    def ShiftFromCenterOfMass(self, mass: float, p_BcmQ_E: numpy.ndarray[numpy.float64[3,1]]) -> RotationalInertia_[float]: ...
    def ShiftToCenterOfMass(self, mass: float, p_QBcm_E: numpy.ndarray[numpy.float64[3,1]]) -> RotationalInertia_[float]: ...
    def ShiftToThenAwayFromCenterOfMass(self, mass: float, p_PBcm_E: numpy.ndarray[numpy.float64[3,1]], p_QBcm_E: numpy.ndarray[numpy.float64[3,1]]) -> RotationalInertia_[float]: ...
    def Trace(self) -> float: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    @overload
    def cols(self) -> int: ...
    @overload
    def cols(self) -> Any: ...
    def get_moments(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_products(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def rows(self) -> int: ...
    @overload
    def rows(self) -> Any: ...
    def __add__(self, arg0: RotationalInertia_[float]) -> RotationalInertia_[float]: ...
    def __copy__(self) -> RotationalInertia_[float]: ...
    def __deepcopy__(self, arg0: dict) -> RotationalInertia_[float]: ...
    def __getitem__(self, arg0: tuple) -> float: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def __iadd__(self, arg0: RotationalInertia_[float]) -> RotationalInertia_[float]: ...
    def __imul__(self, arg0: float) -> RotationalInertia_[float]: ...
    def __isub__(self, arg0: RotationalInertia_[float]) -> RotationalInertia_[float]: ...
    def __itruediv__(self, arg0: float) -> RotationalInertia_[float]: ...
    @overload
    def __mul__(self, arg0: float) -> RotationalInertia_[float]: ...
    @overload
    def __mul__(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __rmul__(self, arg0: float) -> RotationalInertia_[float]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    def __sub__(self, arg0: RotationalInertia_[float]) -> RotationalInertia_[float]: ...
    def __truediv__(self, arg0: float) -> RotationalInertia_[float]: ...

class RotationalInertia_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd, Ixy: pydrake.autodiffutils.AutoDiffXd, Ixz: pydrake.autodiffutils.AutoDiffXd, Iyz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, mass: pydrake.autodiffutils.AutoDiffXd, p_PQ_E: numpy.ndarray[object[3,1]]) -> None: ...
    def CalcMaximumPossibleMomentOfInertia(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcPrincipalMomentsOfInertia(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CopyToFullMatrix3(self) -> numpy.ndarray[object[3,3]]: ...
    @overload
    def CouldBePhysicallyValid(self) -> bool: ...
    @overload
    def CouldBePhysicallyValid(self) -> Any: ...
    def IsNaN(self) -> bool: ...
    def IsNearlyEqualTo(self, other: RotationalInertia_[AutoDiffXd], precision: float) -> bool: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[AutoDiffXd]) -> RotationalInertia_[AutoDiffXd]: ...
    def SetToNaN(self) -> None: ...
    def SetZero(self) -> None: ...
    def ShiftFromCenterOfMass(self, mass: pydrake.autodiffutils.AutoDiffXd, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_[AutoDiffXd]: ...
    def ShiftToCenterOfMass(self, mass: pydrake.autodiffutils.AutoDiffXd, p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_[AutoDiffXd]: ...
    def ShiftToThenAwayFromCenterOfMass(self, mass: pydrake.autodiffutils.AutoDiffXd, p_PBcm_E: numpy.ndarray[object[3,1]], p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_[AutoDiffXd]: ...
    def Trace(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    @overload
    def cols(self) -> int: ...
    @overload
    def cols(self) -> Any: ...
    def get_moments(self) -> numpy.ndarray[object[3,1]]: ...
    def get_products(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def rows(self) -> int: ...
    @overload
    def rows(self) -> Any: ...
    def __add__(self, arg0: RotationalInertia_[AutoDiffXd]) -> RotationalInertia_[AutoDiffXd]: ...
    def __copy__(self) -> RotationalInertia_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> RotationalInertia_[AutoDiffXd]: ...
    def __getitem__(self, arg0: tuple) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __iadd__(self, arg0: RotationalInertia_[AutoDiffXd]) -> RotationalInertia_[AutoDiffXd]: ...
    def __imul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_[AutoDiffXd]: ...
    def __isub__(self, arg0: RotationalInertia_[AutoDiffXd]) -> RotationalInertia_[AutoDiffXd]: ...
    def __itruediv__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_[AutoDiffXd]: ...
    @overload
    def __mul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_[AutoDiffXd]: ...
    @overload
    def __mul__(self, arg0: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def __rmul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_[AutoDiffXd]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    def __sub__(self, arg0: RotationalInertia_[AutoDiffXd]) -> RotationalInertia_[AutoDiffXd]: ...
    def __truediv__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_[AutoDiffXd]: ...

class RotationalInertia_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression, Ixy: pydrake.symbolic.Expression, Ixz: pydrake.symbolic.Expression, Iyz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, mass: pydrake.symbolic.Expression, p_PQ_E: numpy.ndarray[object[3,1]]) -> None: ...
    def CalcMaximumPossibleMomentOfInertia(self) -> pydrake.symbolic.Expression: ...
    def CalcPrincipalMomentsOfInertia(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CopyToFullMatrix3(self) -> numpy.ndarray[object[3,3]]: ...
    @overload
    def CouldBePhysicallyValid(self) -> pydrake.symbolic.Formula: ...
    @overload
    def CouldBePhysicallyValid(self) -> Any: ...
    def IsNaN(self) -> pydrake.symbolic.Formula: ...
    def IsNearlyEqualTo(self, other: RotationalInertia_[Expression], precision: float) -> pydrake.symbolic.Formula: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[Expression]) -> RotationalInertia_[Expression]: ...
    def SetToNaN(self) -> None: ...
    def SetZero(self) -> None: ...
    def ShiftFromCenterOfMass(self, mass: pydrake.symbolic.Expression, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_[Expression]: ...
    def ShiftToCenterOfMass(self, mass: pydrake.symbolic.Expression, p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_[Expression]: ...
    def ShiftToThenAwayFromCenterOfMass(self, mass: pydrake.symbolic.Expression, p_PBcm_E: numpy.ndarray[object[3,1]], p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_[Expression]: ...
    def Trace(self) -> pydrake.symbolic.Expression: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    @overload
    def cols(self) -> int: ...
    @overload
    def cols(self) -> Any: ...
    def get_moments(self) -> numpy.ndarray[object[3,1]]: ...
    def get_products(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def rows(self) -> int: ...
    @overload
    def rows(self) -> Any: ...
    def __add__(self, arg0: RotationalInertia_[Expression]) -> RotationalInertia_[Expression]: ...
    def __copy__(self) -> RotationalInertia_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> RotationalInertia_[Expression]: ...
    def __getitem__(self, arg0: tuple) -> pydrake.symbolic.Expression: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __iadd__(self, arg0: RotationalInertia_[Expression]) -> RotationalInertia_[Expression]: ...
    def __imul__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_[Expression]: ...
    def __isub__(self, arg0: RotationalInertia_[Expression]) -> RotationalInertia_[Expression]: ...
    def __itruediv__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_[Expression]: ...
    @overload
    def __mul__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_[Expression]: ...
    @overload
    def __mul__(self, arg0: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def __rmul__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_[Expression]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    def __sub__(self, arg0: RotationalInertia_[Expression]) -> RotationalInertia_[Expression]: ...
    def __truediv__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_[Expression]: ...

class RotationalInertia_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None: ...
    @overload
    def __init__(self, mass: float, p_PQ_E: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcMaximumPossibleMomentOfInertia(self) -> float: ...
    def CalcPrincipalMomentsOfInertia(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CopyToFullMatrix3(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    @overload
    def CouldBePhysicallyValid(self) -> bool: ...
    @overload
    def CouldBePhysicallyValid(self) -> Any: ...
    def IsNaN(self) -> bool: ...
    def IsNearlyEqualTo(self, other: RotationalInertia_[float], precision: float) -> bool: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[float]) -> RotationalInertia_[float]: ...
    def SetToNaN(self) -> None: ...
    def SetZero(self) -> None: ...
    def ShiftFromCenterOfMass(self, mass: float, p_BcmQ_E: numpy.ndarray[numpy.float64[3,1]]) -> RotationalInertia_[float]: ...
    def ShiftToCenterOfMass(self, mass: float, p_QBcm_E: numpy.ndarray[numpy.float64[3,1]]) -> RotationalInertia_[float]: ...
    def ShiftToThenAwayFromCenterOfMass(self, mass: float, p_PBcm_E: numpy.ndarray[numpy.float64[3,1]], p_QBcm_E: numpy.ndarray[numpy.float64[3,1]]) -> RotationalInertia_[float]: ...
    def Trace(self) -> float: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    @overload
    def cols(self) -> int: ...
    @overload
    def cols(self) -> Any: ...
    def get_moments(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_products(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def rows(self) -> int: ...
    @overload
    def rows(self) -> Any: ...
    def __add__(self, arg0: RotationalInertia_[float]) -> RotationalInertia_[float]: ...
    def __copy__(self) -> RotationalInertia_[float]: ...
    def __deepcopy__(self, arg0: dict) -> RotationalInertia_[float]: ...
    def __getitem__(self, arg0: tuple) -> float: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def __iadd__(self, arg0: RotationalInertia_[float]) -> RotationalInertia_[float]: ...
    def __imul__(self, arg0: float) -> RotationalInertia_[float]: ...
    def __isub__(self, arg0: RotationalInertia_[float]) -> RotationalInertia_[float]: ...
    def __itruediv__(self, arg0: float) -> RotationalInertia_[float]: ...
    @overload
    def __mul__(self, arg0: float) -> RotationalInertia_[float]: ...
    @overload
    def __mul__(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __rmul__(self, arg0: float) -> RotationalInertia_[float]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    def __sub__(self, arg0: RotationalInertia_[float]) -> RotationalInertia_[float]: ...
    def __truediv__(self, arg0: float) -> RotationalInertia_[float]: ...

class ScrewJoint(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], screw_pitch: Optional[float] = ..., damping: Optional[float] = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], axis: numpy.ndarray[numpy.float64[3,1]], screw_pitch: float, damping: float) -> None: ...
    def damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def screw_pitch(self) -> float: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[float], theta_dot: float) -> ScrewJoint_[float]: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, z: float) -> None: ...
    def set_random_pose_distribution(self, theta: numpy.ndarray[object[1,1]]) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[float], translation: float) -> ScrewJoint_[float]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[float], translation_dot: float) -> ScrewJoint_[float]: ...

class ScrewJoint_[AutoDiffXd](Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], screw_pitch: Optional[float] = ..., damping: Optional[float] = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3,1]], screw_pitch: float, damping: float) -> None: ...
    def damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def screw_pitch(self) -> float: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], theta_dot: pydrake.autodiffutils.AutoDiffXd) -> ScrewJoint_[AutoDiffXd]: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, z: float) -> None: ...
    def set_random_pose_distribution(self, theta: numpy.ndarray[object[1,1]]) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[AutoDiffXd], translation: pydrake.autodiffutils.AutoDiffXd) -> ScrewJoint_[AutoDiffXd]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], translation_dot: pydrake.autodiffutils.AutoDiffXd) -> ScrewJoint_[AutoDiffXd]: ...

class ScrewJoint_[Expression](Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], screw_pitch: Optional[float] = ..., damping: Optional[float] = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], axis: numpy.ndarray[numpy.float64[3,1]], screw_pitch: float, damping: float) -> None: ...
    def damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def screw_pitch(self) -> float: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression], theta_dot: pydrake.symbolic.Expression) -> ScrewJoint_[Expression]: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, z: float) -> None: ...
    def set_random_pose_distribution(self, theta: numpy.ndarray[object[1,1]]) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[Expression], translation: pydrake.symbolic.Expression) -> ScrewJoint_[Expression]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[Expression], translation_dot: pydrake.symbolic.Expression) -> ScrewJoint_[Expression]: ...

class ScrewJoint_[float](Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], screw_pitch: Optional[float] = ..., damping: Optional[float] = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], axis: numpy.ndarray[numpy.float64[3,1]], screw_pitch: float, damping: float) -> None: ...
    def damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def screw_pitch(self) -> float: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[float], theta_dot: float) -> ScrewJoint_[float]: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, z: float) -> None: ...
    def set_random_pose_distribution(self, theta: numpy.ndarray[object[1,1]]) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[float], translation: float) -> ScrewJoint_[float]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[float], translation_dot: float) -> ScrewJoint_[float]: ...

class SpatialInertia:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mass: float, p_PScm_E: numpy.ndarray[numpy.float64[3,1]], G_SP_E: UnitInertia_[float], skip_validity_check: bool = ...) -> None: ...
    def CalcComMoment(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcRotationalInertia(self) -> RotationalInertia_[float]: ...
    def CopyToFullMatrix6(self) -> numpy.ndarray[numpy.float64[6,6]]: ...
    def IsNaN(self) -> bool: ...
    def IsPhysicallyValid(self) -> bool: ...
    def MakeFromCentralInertia(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[float]) -> SpatialInertia_[float]: ...
    def SetNaN(self) -> None: ...
    def Shift(self, p_PQ_E: numpy.ndarray[numpy.float64[3,1]]) -> SpatialInertia_[float]: ...
    def get_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_mass(self) -> float: ...
    def get_unit_inertia(self) -> UnitInertia_[float]: ...
    def __copy__(self) -> SpatialInertia_[float]: ...
    def __deepcopy__(self, arg0: dict) -> SpatialInertia_[float]: ...
    def __getstate__(self) -> tuple: ...
    def __iadd__(self, arg0: SpatialInertia_[float]) -> SpatialInertia_[float]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialAcceleration_[float]) -> pydrake.multibody.math.SpatialForce_[float]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialVelocity_[float]) -> pydrake.multibody.math.SpatialMomentum_[float]: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class SpatialInertia_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mass: pydrake.autodiffutils.AutoDiffXd, p_PScm_E: numpy.ndarray[object[3,1]], G_SP_E: UnitInertia_[AutoDiffXd], skip_validity_check: bool = ...) -> None: ...
    def CalcComMoment(self) -> numpy.ndarray[object[3,1]]: ...
    def CalcRotationalInertia(self) -> RotationalInertia_[AutoDiffXd]: ...
    def CopyToFullMatrix6(self) -> numpy.ndarray[object[6,6]]: ...
    def IsNaN(self) -> bool: ...
    def IsPhysicallyValid(self) -> bool: ...
    def MakeFromCentralInertia(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[AutoDiffXd]) -> SpatialInertia_[AutoDiffXd]: ...
    def SetNaN(self) -> None: ...
    def Shift(self, p_PQ_E: numpy.ndarray[object[3,1]]) -> SpatialInertia_[AutoDiffXd]: ...
    def get_com(self) -> numpy.ndarray[object[3,1]]: ...
    def get_mass(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_unit_inertia(self) -> UnitInertia_[AutoDiffXd]: ...
    def __copy__(self) -> SpatialInertia_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> SpatialInertia_[AutoDiffXd]: ...
    def __getstate__(self) -> tuple: ...
    def __iadd__(self, arg0: SpatialInertia_[AutoDiffXd]) -> SpatialInertia_[AutoDiffXd]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]) -> pydrake.multibody.math.SpatialForce_[AutoDiffXd]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]) -> pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class SpatialInertia_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mass: pydrake.symbolic.Expression, p_PScm_E: numpy.ndarray[object[3,1]], G_SP_E: UnitInertia_[Expression], skip_validity_check: bool = ...) -> None: ...
    def CalcComMoment(self) -> numpy.ndarray[object[3,1]]: ...
    def CalcRotationalInertia(self) -> RotationalInertia_[Expression]: ...
    def CopyToFullMatrix6(self) -> numpy.ndarray[object[6,6]]: ...
    def IsNaN(self) -> pydrake.symbolic.Formula: ...
    def IsPhysicallyValid(self) -> pydrake.symbolic.Formula: ...
    def MakeFromCentralInertia(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[Expression]) -> SpatialInertia_[Expression]: ...
    def SetNaN(self) -> None: ...
    def Shift(self, p_PQ_E: numpy.ndarray[object[3,1]]) -> SpatialInertia_[Expression]: ...
    def get_com(self) -> numpy.ndarray[object[3,1]]: ...
    def get_mass(self) -> pydrake.symbolic.Expression: ...
    def get_unit_inertia(self) -> UnitInertia_[Expression]: ...
    def __copy__(self) -> SpatialInertia_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> SpatialInertia_[Expression]: ...
    def __getstate__(self) -> tuple: ...
    def __iadd__(self, arg0: SpatialInertia_[Expression]) -> SpatialInertia_[Expression]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialAcceleration_[Expression]) -> pydrake.multibody.math.SpatialForce_[Expression]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialVelocity_[Expression]) -> pydrake.multibody.math.SpatialMomentum_[Expression]: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class SpatialInertia_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mass: float, p_PScm_E: numpy.ndarray[numpy.float64[3,1]], G_SP_E: UnitInertia_[float], skip_validity_check: bool = ...) -> None: ...
    def CalcComMoment(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcRotationalInertia(self) -> RotationalInertia_[float]: ...
    def CopyToFullMatrix6(self) -> numpy.ndarray[numpy.float64[6,6]]: ...
    def IsNaN(self) -> bool: ...
    def IsPhysicallyValid(self) -> bool: ...
    def MakeFromCentralInertia(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[float]) -> SpatialInertia_[float]: ...
    def SetNaN(self) -> None: ...
    def Shift(self, p_PQ_E: numpy.ndarray[numpy.float64[3,1]]) -> SpatialInertia_[float]: ...
    def get_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_mass(self) -> float: ...
    def get_unit_inertia(self) -> UnitInertia_[float]: ...
    def __copy__(self) -> SpatialInertia_[float]: ...
    def __deepcopy__(self, arg0: dict) -> SpatialInertia_[float]: ...
    def __getstate__(self) -> tuple: ...
    def __iadd__(self, arg0: SpatialInertia_[float]) -> SpatialInertia_[float]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialAcceleration_[float]) -> pydrake.multibody.math.SpatialForce_[float]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialVelocity_[float]) -> pydrake.multibody.math.SpatialMomentum_[float]: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class UniformGravityFieldElement(ForceElement_[float]):
    kDefaultStrength: ClassVar[float] = ...  # read-only
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, g_W: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def gravity_vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_gravity_vector(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class UniformGravityFieldElement_[AutoDiffXd](ForceElement_[AutoDiffXd]):
    kDefaultStrength: ClassVar[float] = ...  # read-only
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, g_W: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    def gravity_vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_gravity_vector(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class UniformGravityFieldElement_[Expression](ForceElement_[Expression]):
    kDefaultStrength: ClassVar[float] = ...  # read-only
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, g_W: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    def gravity_vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_gravity_vector(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class UniformGravityFieldElement_[float](ForceElement_[float]):
    kDefaultStrength: ClassVar[float] = ...  # read-only
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, g_W: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def gravity_vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_gravity_vector(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class UnitInertia(RotationalInertia_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None: ...
    @overload
    def __init__(self, I: RotationalInertia_[float]) -> None: ...
    def AxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def HollowSphere(self, *args, **kwargs) -> Any: ...
    def PointMass(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[float]) -> UnitInertia_[float]: ...
    def SetFromRotationalInertia(self, I: RotationalInertia_[float], mass: float) -> UnitInertia_[float]: ...
    def ShiftFromCenterOfMass(self, p_BcmQ_E: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia_[float]: ...
    def ShiftToCenterOfMass(self, p_QBcm_E: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia_[float]: ...
    def SolidBox(self, *args, **kwargs) -> Any: ...
    def SolidCapsule(self, *args, **kwargs) -> Any: ...
    def SolidCube(self, *args, **kwargs) -> Any: ...
    def SolidCylinder(self, *args, **kwargs) -> Any: ...
    def SolidCylinderAboutEnd(self, *args, **kwargs) -> Any: ...
    def SolidEllipsoid(self, *args, **kwargs) -> Any: ...
    def SolidSphere(self, *args, **kwargs) -> Any: ...
    def StraightLine(self, *args, **kwargs) -> Any: ...
    def ThinRod(self, *args, **kwargs) -> Any: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> UnitInertia_[float]: ...
    def __deepcopy__(self, arg0: dict) -> UnitInertia_[float]: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...

class UnitInertia_[AutoDiffXd](RotationalInertia_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd, Ixy: pydrake.autodiffutils.AutoDiffXd, Ixz: pydrake.autodiffutils.AutoDiffXd, Iyz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, I: RotationalInertia_[AutoDiffXd]) -> None: ...
    def AxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def HollowSphere(self, *args, **kwargs) -> Any: ...
    def PointMass(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[AutoDiffXd]) -> UnitInertia_[AutoDiffXd]: ...
    def SetFromRotationalInertia(self, I: RotationalInertia_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_[AutoDiffXd]: ...
    def ShiftFromCenterOfMass(self, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> UnitInertia_[AutoDiffXd]: ...
    def ShiftToCenterOfMass(self, p_QBcm_E: numpy.ndarray[object[3,1]]) -> UnitInertia_[AutoDiffXd]: ...
    def SolidBox(self, *args, **kwargs) -> Any: ...
    def SolidCapsule(self, *args, **kwargs) -> Any: ...
    def SolidCube(self, *args, **kwargs) -> Any: ...
    def SolidCylinder(self, *args, **kwargs) -> Any: ...
    def SolidCylinderAboutEnd(self, *args, **kwargs) -> Any: ...
    def SolidEllipsoid(self, *args, **kwargs) -> Any: ...
    def SolidSphere(self, *args, **kwargs) -> Any: ...
    def StraightLine(self, *args, **kwargs) -> Any: ...
    def ThinRod(self, *args, **kwargs) -> Any: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> UnitInertia_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> UnitInertia_[AutoDiffXd]: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...

class UnitInertia_[Expression](RotationalInertia_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression, Ixy: pydrake.symbolic.Expression, Ixz: pydrake.symbolic.Expression, Iyz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, I: RotationalInertia_[Expression]) -> None: ...
    def AxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def HollowSphere(self, *args, **kwargs) -> Any: ...
    def PointMass(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[Expression]) -> UnitInertia_[Expression]: ...
    def SetFromRotationalInertia(self, I: RotationalInertia_[Expression], mass: pydrake.symbolic.Expression) -> UnitInertia_[Expression]: ...
    def ShiftFromCenterOfMass(self, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> UnitInertia_[Expression]: ...
    def ShiftToCenterOfMass(self, p_QBcm_E: numpy.ndarray[object[3,1]]) -> UnitInertia_[Expression]: ...
    def SolidBox(self, *args, **kwargs) -> Any: ...
    def SolidCapsule(self, *args, **kwargs) -> Any: ...
    def SolidCube(self, *args, **kwargs) -> Any: ...
    def SolidCylinder(self, *args, **kwargs) -> Any: ...
    def SolidCylinderAboutEnd(self, *args, **kwargs) -> Any: ...
    def SolidEllipsoid(self, *args, **kwargs) -> Any: ...
    def SolidSphere(self, *args, **kwargs) -> Any: ...
    def StraightLine(self, *args, **kwargs) -> Any: ...
    def ThinRod(self, *args, **kwargs) -> Any: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> UnitInertia_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> UnitInertia_[Expression]: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...

class UnitInertia_[float](RotationalInertia_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None: ...
    @overload
    def __init__(self, I: RotationalInertia_[float]) -> None: ...
    def AxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def HollowSphere(self, *args, **kwargs) -> Any: ...
    def PointMass(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[float]) -> UnitInertia_[float]: ...
    def SetFromRotationalInertia(self, I: RotationalInertia_[float], mass: float) -> UnitInertia_[float]: ...
    def ShiftFromCenterOfMass(self, p_BcmQ_E: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia_[float]: ...
    def ShiftToCenterOfMass(self, p_QBcm_E: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia_[float]: ...
    def SolidBox(self, *args, **kwargs) -> Any: ...
    def SolidCapsule(self, *args, **kwargs) -> Any: ...
    def SolidCube(self, *args, **kwargs) -> Any: ...
    def SolidCylinder(self, *args, **kwargs) -> Any: ...
    def SolidCylinderAboutEnd(self, *args, **kwargs) -> Any: ...
    def SolidEllipsoid(self, *args, **kwargs) -> Any: ...
    def SolidSphere(self, *args, **kwargs) -> Any: ...
    def StraightLine(self, *args, **kwargs) -> Any: ...
    def ThinRod(self, *args, **kwargs) -> Any: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> UnitInertia_[float]: ...
    def __deepcopy__(self, arg0: dict) -> UnitInertia_[float]: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...

class UniversalJoint(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_angular_rates(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[2,1]]) -> UniversalJoint_[float]: ...
    def set_angular_rates(self, context: pydrake.systems.framework.Context_[float], theta_dot: numpy.ndarray[numpy.float64[2,1]]) -> UniversalJoint_[float]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[2,1]]) -> None: ...

class UniversalJoint_[AutoDiffXd](Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[2,1]]: ...
    def get_angular_rates(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[2,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[AutoDiffXd], angles: numpy.ndarray[object[2,1]]) -> UniversalJoint_[AutoDiffXd]: ...
    def set_angular_rates(self, context: pydrake.systems.framework.Context_[AutoDiffXd], theta_dot: numpy.ndarray[object[2,1]]) -> UniversalJoint_[AutoDiffXd]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[2,1]]) -> None: ...

class UniversalJoint_[Expression](Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[2,1]]: ...
    def get_angular_rates(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[2,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[Expression], angles: numpy.ndarray[object[2,1]]) -> UniversalJoint_[Expression]: ...
    def set_angular_rates(self, context: pydrake.systems.framework.Context_[Expression], theta_dot: numpy.ndarray[object[2,1]]) -> UniversalJoint_[Expression]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[2,1]]) -> None: ...

class UniversalJoint_[float](Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_angular_rates(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[2,1]]) -> UniversalJoint_[float]: ...
    def set_angular_rates(self, context: pydrake.systems.framework.Context_[float], theta_dot: numpy.ndarray[numpy.float64[2,1]]) -> UniversalJoint_[float]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[2,1]]) -> None: ...

class WeldJoint(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent_F: Frame_[float], frame_on_child_M: Frame_[float], X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def X_FM(self) -> pydrake.math.RigidTransform_[float]: ...

class WeldJoint_[AutoDiffXd](Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent_F: Frame_[AutoDiffXd], frame_on_child_M: Frame_[AutoDiffXd], X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def X_FM(self) -> pydrake.math.RigidTransform_[float]: ...

class WeldJoint_[Expression](Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent_F: Frame_[Expression], frame_on_child_M: Frame_[Expression], X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def X_FM(self) -> pydrake.math.RigidTransform_[float]: ...

class WeldJoint_[float](Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent_F: Frame_[float], frame_on_child_M: Frame_[float], X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def X_FM(self) -> pydrake.math.RigidTransform_[float]: ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody13ConstraintTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ConstraintIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ConstraintIndex: ...
    def get_value(self) -> ConstraintIndex: ...
    def set_value(self, arg0: ConstraintIndex) -> None: ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody15ForceElementTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ForceElementIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ForceElementIndex: ...
    def get_value(self) -> ForceElementIndex: ...
    def set_value(self, arg0: ForceElementIndex) -> None: ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody15JointElementTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: JointIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> JointIndex: ...
    def get_value(self) -> JointIndex: ...
    def set_value(self, arg0: JointIndex) -> None: ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody16ModelInstanceTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ModelInstanceIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ModelInstanceIndex: ...
    def get_value(self) -> ModelInstanceIndex: ...
    def set_value(self, arg0: ModelInstanceIndex) -> None: ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody23JointActuatorElementTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: JointActuatorIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> JointActuatorIndex: ...
    def get_value(self) -> JointActuatorIndex: ...
    def set_value(self, arg0: JointActuatorIndex) -> None: ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody7BodyTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: BodyIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> BodyIndex: ...
    def get_value(self) -> BodyIndex: ...
    def set_value(self, arg0: BodyIndex) -> None: ...

class _TemporaryName_N5drake5ValueINS_13TypeSafeIndexINS_9multibody8FrameTagEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: FrameIndex) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> FrameIndex: ...
    def get_value(self) -> FrameIndex: ...
    def set_value(self, arg0: FrameIndex) -> None: ...

class _TemporaryName_N5drake9multibody10ScrewJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], screw_pitch: Optional[float] = ..., damping: Optional[float] = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3,1]], screw_pitch: float, damping: float) -> None: ...
    def damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def screw_pitch(self) -> float: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], theta_dot: pydrake.autodiffutils.AutoDiffXd) -> ScrewJoint_[AutoDiffXd]: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, z: float) -> None: ...
    def set_random_pose_distribution(self, theta: numpy.ndarray[object[1,1]]) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[AutoDiffXd], translation: pydrake.autodiffutils.AutoDiffXd) -> ScrewJoint_[AutoDiffXd]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], translation_dot: pydrake.autodiffutils.AutoDiffXd) -> ScrewJoint_[AutoDiffXd]: ...

class _TemporaryName_N5drake9multibody10ScrewJointINS_8symbolic10ExpressionEEE(Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], screw_pitch: Optional[float] = ..., damping: Optional[float] = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], axis: numpy.ndarray[numpy.float64[3,1]], screw_pitch: float, damping: float) -> None: ...
    def damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def screw_pitch(self) -> float: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression], theta_dot: pydrake.symbolic.Expression) -> ScrewJoint_[Expression]: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, z: float) -> None: ...
    def set_random_pose_distribution(self, theta: numpy.ndarray[object[1,1]]) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[Expression], translation: pydrake.symbolic.Expression) -> ScrewJoint_[Expression]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[Expression], translation_dot: pydrake.symbolic.Expression) -> ScrewJoint_[Expression]: ...

class _TemporaryName_N5drake9multibody10ScrewJointIdEE(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], screw_pitch: Optional[float] = ..., damping: Optional[float] = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], axis: numpy.ndarray[numpy.float64[3,1]], screw_pitch: float, damping: float) -> None: ...
    def damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def screw_pitch(self) -> float: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[float], theta_dot: float) -> ScrewJoint_[float]: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, z: float) -> None: ...
    def set_random_pose_distribution(self, theta: numpy.ndarray[object[1,1]]) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[float], translation: float) -> ScrewJoint_[float]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[float], translation_dot: float) -> ScrewJoint_[float]: ...

class _TemporaryName_N5drake9multibody11PlanarJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], damping: numpy.ndarray[numpy.float64[3,1]] = ...) -> None: ...
    def damping(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[2,1]]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[2,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], theta_dot: pydrake.autodiffutils.AutoDiffXd) -> PlanarJoint_[AutoDiffXd]: ...
    def set_default_pose(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> None: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[AutoDiffXd], p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.autodiffutils.AutoDiffXd) -> PlanarJoint_[AutoDiffXd]: ...
    def set_random_pose_distribution(self, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> None: ...
    def set_rotation(self, context: pydrake.systems.framework.Context_[AutoDiffXd], theta: pydrake.autodiffutils.AutoDiffXd) -> PlanarJoint_[AutoDiffXd]: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[AutoDiffXd], p_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_[AutoDiffXd]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], v_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_[AutoDiffXd]: ...

class _TemporaryName_N5drake9multibody11PlanarJointINS_8symbolic10ExpressionEEE(Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], damping: numpy.ndarray[numpy.float64[3,1]] = ...) -> None: ...
    def damping(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[2,1]]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[2,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression], theta_dot: pydrake.symbolic.Expression) -> PlanarJoint_[Expression]: ...
    def set_default_pose(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> None: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[Expression], p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> PlanarJoint_[Expression]: ...
    def set_random_pose_distribution(self, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> None: ...
    def set_rotation(self, context: pydrake.systems.framework.Context_[Expression], theta: pydrake.symbolic.Expression) -> PlanarJoint_[Expression]: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[Expression], p_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_[Expression]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[Expression], v_FoMo_F: numpy.ndarray[object[2,1]]) -> PlanarJoint_[Expression]: ...

class _TemporaryName_N5drake9multibody11PlanarJointIdEE(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], damping: numpy.ndarray[numpy.float64[3,1]] = ...) -> None: ...
    def damping(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_default_rotation(self) -> float: ...
    def get_default_translation(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_rotation(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[float], theta_dot: float) -> PlanarJoint_[float]: ...
    def set_default_pose(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> None: ...
    def set_default_rotation(self, theta: float) -> None: ...
    def set_default_translation(self, p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2,1]], theta: float) -> PlanarJoint_[float]: ...
    def set_random_pose_distribution(self, p_FoMo_F: numpy.ndarray[object[2,1]], theta: pydrake.symbolic.Expression) -> None: ...
    def set_rotation(self, context: pydrake.systems.framework.Context_[float], theta: float) -> PlanarJoint_[float]: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> PlanarJoint_[float]: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[float], v_FoMo_F: numpy.ndarray[numpy.float64[2,1]]) -> PlanarJoint_[float]: ...

class _TemporaryName_N5drake9multibody11UnitInertiaIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(RotationalInertia_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd, Ixy: pydrake.autodiffutils.AutoDiffXd, Ixz: pydrake.autodiffutils.AutoDiffXd, Iyz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, I: RotationalInertia_[AutoDiffXd]) -> None: ...
    def AxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def HollowSphere(self, *args, **kwargs) -> Any: ...
    def PointMass(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[AutoDiffXd]) -> UnitInertia_[AutoDiffXd]: ...
    def SetFromRotationalInertia(self, I: RotationalInertia_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd) -> UnitInertia_[AutoDiffXd]: ...
    def ShiftFromCenterOfMass(self, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> UnitInertia_[AutoDiffXd]: ...
    def ShiftToCenterOfMass(self, p_QBcm_E: numpy.ndarray[object[3,1]]) -> UnitInertia_[AutoDiffXd]: ...
    def SolidBox(self, *args, **kwargs) -> Any: ...
    def SolidCapsule(self, *args, **kwargs) -> Any: ...
    def SolidCube(self, *args, **kwargs) -> Any: ...
    def SolidCylinder(self, *args, **kwargs) -> Any: ...
    def SolidCylinderAboutEnd(self, *args, **kwargs) -> Any: ...
    def SolidEllipsoid(self, *args, **kwargs) -> Any: ...
    def SolidSphere(self, *args, **kwargs) -> Any: ...
    def StraightLine(self, *args, **kwargs) -> Any: ...
    def ThinRod(self, *args, **kwargs) -> Any: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> UnitInertia_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> UnitInertia_[AutoDiffXd]: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...

class _TemporaryName_N5drake9multibody11UnitInertiaINS_8symbolic10ExpressionEEE(RotationalInertia_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression, Ixy: pydrake.symbolic.Expression, Ixz: pydrake.symbolic.Expression, Iyz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, I: RotationalInertia_[Expression]) -> None: ...
    def AxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def HollowSphere(self, *args, **kwargs) -> Any: ...
    def PointMass(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[Expression]) -> UnitInertia_[Expression]: ...
    def SetFromRotationalInertia(self, I: RotationalInertia_[Expression], mass: pydrake.symbolic.Expression) -> UnitInertia_[Expression]: ...
    def ShiftFromCenterOfMass(self, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> UnitInertia_[Expression]: ...
    def ShiftToCenterOfMass(self, p_QBcm_E: numpy.ndarray[object[3,1]]) -> UnitInertia_[Expression]: ...
    def SolidBox(self, *args, **kwargs) -> Any: ...
    def SolidCapsule(self, *args, **kwargs) -> Any: ...
    def SolidCube(self, *args, **kwargs) -> Any: ...
    def SolidCylinder(self, *args, **kwargs) -> Any: ...
    def SolidCylinderAboutEnd(self, *args, **kwargs) -> Any: ...
    def SolidEllipsoid(self, *args, **kwargs) -> Any: ...
    def SolidSphere(self, *args, **kwargs) -> Any: ...
    def StraightLine(self, *args, **kwargs) -> Any: ...
    def ThinRod(self, *args, **kwargs) -> Any: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> UnitInertia_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> UnitInertia_[Expression]: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...

class _TemporaryName_N5drake9multibody11UnitInertiaIdEE(RotationalInertia_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None: ...
    @overload
    def __init__(self, I: RotationalInertia_[float]) -> None: ...
    def AxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def HollowSphere(self, *args, **kwargs) -> Any: ...
    def PointMass(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[float]) -> UnitInertia_[float]: ...
    def SetFromRotationalInertia(self, I: RotationalInertia_[float], mass: float) -> UnitInertia_[float]: ...
    def ShiftFromCenterOfMass(self, p_BcmQ_E: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia_[float]: ...
    def ShiftToCenterOfMass(self, p_QBcm_E: numpy.ndarray[numpy.float64[3,1]]) -> UnitInertia_[float]: ...
    def SolidBox(self, *args, **kwargs) -> Any: ...
    def SolidCapsule(self, *args, **kwargs) -> Any: ...
    def SolidCube(self, *args, **kwargs) -> Any: ...
    def SolidCylinder(self, *args, **kwargs) -> Any: ...
    def SolidCylinderAboutEnd(self, *args, **kwargs) -> Any: ...
    def SolidEllipsoid(self, *args, **kwargs) -> Any: ...
    def SolidSphere(self, *args, **kwargs) -> Any: ...
    def StraightLine(self, *args, **kwargs) -> Any: ...
    def ThinRod(self, *args, **kwargs) -> Any: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> UnitInertia_[float]: ...
    def __deepcopy__(self, arg0: dict) -> UnitInertia_[float]: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...

class _TemporaryName_N5drake9multibody12BallRpyJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[AutoDiffXd], angles: numpy.ndarray[object[3,1]]) -> BallRpyJoint_[AutoDiffXd]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], w_FM: numpy.ndarray[object[3,1]]) -> BallRpyJoint_[AutoDiffXd]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[3,1]]) -> None: ...

class _TemporaryName_N5drake9multibody12BallRpyJointINS_8symbolic10ExpressionEEE(Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[Expression], angles: numpy.ndarray[object[3,1]]) -> BallRpyJoint_[Expression]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression], w_FM: numpy.ndarray[object[3,1]]) -> BallRpyJoint_[Expression]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[3,1]]) -> None: ...

class _TemporaryName_N5drake9multibody12BallRpyJointIdEE(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[3,1]]) -> BallRpyJoint_[float]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[float], w_FM: numpy.ndarray[numpy.float64[3,1]]) -> BallRpyJoint_[float]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[3,1]]) -> None: ...

class _TemporaryName_N5drake9multibody12ForceElementIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def index(self) -> ForceElementIndex: ...
    def model_instance(self) -> ModelInstanceIndex: ...

class _TemporaryName_N5drake9multibody12ForceElementINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def index(self) -> ForceElementIndex: ...
    def model_instance(self) -> ModelInstanceIndex: ...

class _TemporaryName_N5drake9multibody12ForceElementIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def index(self) -> ForceElementIndex: ...
    def model_instance(self) -> ModelInstanceIndex: ...

class _TemporaryName_N5drake9multibody13JointActuatorIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def effort_limit(self) -> float: ...
    def get_actuation_vector(self, u: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def index(self) -> JointActuatorIndex: ...
    def input_start(self) -> int: ...
    def joint(self) -> Joint_[AutoDiffXd]: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_inputs(self) -> int: ...
    def set_actuation_vector(self, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...

class _TemporaryName_N5drake9multibody13JointActuatorINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def effort_limit(self) -> float: ...
    def get_actuation_vector(self, u: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def index(self) -> JointActuatorIndex: ...
    def input_start(self) -> int: ...
    def joint(self) -> Joint_[Expression]: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_inputs(self) -> int: ...
    def set_actuation_vector(self, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...

class _TemporaryName_N5drake9multibody13JointActuatorIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def effort_limit(self) -> float: ...
    def get_actuation_vector(self, u: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def index(self) -> JointActuatorIndex: ...
    def input_start(self) -> int: ...
    def joint(self) -> Joint_[float]: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_inputs(self) -> int: ...
    def set_actuation_vector(self, u_instance: numpy.ndarray[numpy.float64[m,1]], u: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...

class _TemporaryName_N5drake9multibody13RevoluteJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3,1]], damping: float = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_angle(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_angular_rate(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_default_angle(self) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def revolute_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angle(self, context: pydrake.systems.framework.Context_[AutoDiffXd], angle: pydrake.autodiffutils.AutoDiffXd) -> RevoluteJoint_[AutoDiffXd]: ...
    def set_angular_rate(self, context: pydrake.systems.framework.Context_[AutoDiffXd], angle: pydrake.autodiffutils.AutoDiffXd) -> RevoluteJoint_[AutoDiffXd]: ...
    def set_default_angle(self, angle: float) -> None: ...
    def set_random_angle_distribution(self, angle: pydrake.symbolic.Expression) -> None: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class _TemporaryName_N5drake9multibody13RevoluteJointINS_8symbolic10ExpressionEEE(Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], axis: numpy.ndarray[numpy.float64[3,1]], damping: float = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_angle(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_angular_rate(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_default_angle(self) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def revolute_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angle(self, context: pydrake.systems.framework.Context_[Expression], angle: pydrake.symbolic.Expression) -> RevoluteJoint_[Expression]: ...
    def set_angular_rate(self, context: pydrake.systems.framework.Context_[Expression], angle: pydrake.symbolic.Expression) -> RevoluteJoint_[Expression]: ...
    def set_default_angle(self, angle: float) -> None: ...
    def set_random_angle_distribution(self, angle: pydrake.symbolic.Expression) -> None: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class _TemporaryName_N5drake9multibody13RevoluteJointIdEE(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], axis: numpy.ndarray[numpy.float64[3,1]], damping: float = ...) -> None: ...
    @overload
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_angle(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_angular_rate(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_default_angle(self) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def revolute_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angle(self, context: pydrake.systems.framework.Context_[float], angle: float) -> RevoluteJoint_[float]: ...
    def set_angular_rate(self, context: pydrake.systems.framework.Context_[float], angle: float) -> RevoluteJoint_[float]: ...
    def set_default_angle(self, angle: float) -> None: ...
    def set_random_angle_distribution(self, angle: pydrake.symbolic.Expression) -> None: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class _TemporaryName_N5drake9multibody14PrismaticJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float = ..., pos_upper_limit: float = ..., damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_translation_rate(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def set_default_translation(self, translation: float) -> None: ...
    def set_random_translation_distribution(self, translation: pydrake.symbolic.Expression) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[AutoDiffXd], translation: pydrake.autodiffutils.AutoDiffXd) -> PrismaticJoint_[AutoDiffXd]: ...
    def set_translation_rate(self, context: pydrake.systems.framework.Context_[AutoDiffXd], translation_dot: pydrake.autodiffutils.AutoDiffXd) -> PrismaticJoint_[AutoDiffXd]: ...
    def translation_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class _TemporaryName_N5drake9multibody14PrismaticJointINS_8symbolic10ExpressionEEE(Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float = ..., pos_upper_limit: float = ..., damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_translation_rate(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def set_default_translation(self, translation: float) -> None: ...
    def set_random_translation_distribution(self, translation: pydrake.symbolic.Expression) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[Expression], translation: pydrake.symbolic.Expression) -> PrismaticJoint_[Expression]: ...
    def set_translation_rate(self, context: pydrake.systems.framework.Context_[Expression], translation_dot: pydrake.symbolic.Expression) -> PrismaticJoint_[Expression]: ...
    def translation_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class _TemporaryName_N5drake9multibody14PrismaticJointIdEE(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], axis: numpy.ndarray[numpy.float64[3,1]], pos_lower_limit: float = ..., pos_upper_limit: float = ..., damping: float = ...) -> None: ...
    def acceleration_lower_limit(self) -> float: ...
    def acceleration_upper_limit(self) -> float: ...
    def damping(self) -> float: ...
    def get_default_translation(self) -> float: ...
    def get_translation(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_translation_rate(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def position_lower_limit(self) -> float: ...
    def position_upper_limit(self) -> float: ...
    def set_default_translation(self, translation: float) -> None: ...
    def set_random_translation_distribution(self, translation: pydrake.symbolic.Expression) -> None: ...
    def set_translation(self, context: pydrake.systems.framework.Context_[float], translation: float) -> PrismaticJoint_[float]: ...
    def set_translation_rate(self, context: pydrake.systems.framework.Context_[float], translation_dot: float) -> PrismaticJoint_[float]: ...
    def translation_axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def velocity_lower_limit(self) -> float: ...
    def velocity_upper_limit(self) -> float: ...

class _TemporaryName_N5drake9multibody14RevoluteSpringIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(ForceElement_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[AutoDiffXd], nominal_angle: float, stiffness: float) -> None: ...
    def joint(self) -> RevoluteJoint_[AutoDiffXd]: ...
    def nominal_angle(self) -> float: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody14RevoluteSpringINS_8symbolic10ExpressionEEE(ForceElement_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[Expression], nominal_angle: float, stiffness: float) -> None: ...
    def joint(self) -> RevoluteJoint_[Expression]: ...
    def nominal_angle(self) -> float: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody14RevoluteSpringIdEE(ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[float], nominal_angle: float, stiffness: float) -> None: ...
    def joint(self) -> RevoluteJoint_[float]: ...
    def nominal_angle(self) -> float: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody14SpatialInertiaIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mass: pydrake.autodiffutils.AutoDiffXd, p_PScm_E: numpy.ndarray[object[3,1]], G_SP_E: UnitInertia_[AutoDiffXd], skip_validity_check: bool = ...) -> None: ...
    def CalcComMoment(self) -> numpy.ndarray[object[3,1]]: ...
    def CalcRotationalInertia(self) -> RotationalInertia_[AutoDiffXd]: ...
    def CopyToFullMatrix6(self) -> numpy.ndarray[object[6,6]]: ...
    def IsNaN(self) -> bool: ...
    def IsPhysicallyValid(self) -> bool: ...
    def MakeFromCentralInertia(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[AutoDiffXd]) -> SpatialInertia_[AutoDiffXd]: ...
    def SetNaN(self) -> None: ...
    def Shift(self, p_PQ_E: numpy.ndarray[object[3,1]]) -> SpatialInertia_[AutoDiffXd]: ...
    def get_com(self) -> numpy.ndarray[object[3,1]]: ...
    def get_mass(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_unit_inertia(self) -> UnitInertia_[AutoDiffXd]: ...
    def __copy__(self) -> SpatialInertia_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> SpatialInertia_[AutoDiffXd]: ...
    def __getstate__(self) -> tuple: ...
    def __iadd__(self, arg0: SpatialInertia_[AutoDiffXd]) -> SpatialInertia_[AutoDiffXd]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]) -> pydrake.multibody.math.SpatialForce_[AutoDiffXd]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]) -> pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class _TemporaryName_N5drake9multibody14SpatialInertiaINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mass: pydrake.symbolic.Expression, p_PScm_E: numpy.ndarray[object[3,1]], G_SP_E: UnitInertia_[Expression], skip_validity_check: bool = ...) -> None: ...
    def CalcComMoment(self) -> numpy.ndarray[object[3,1]]: ...
    def CalcRotationalInertia(self) -> RotationalInertia_[Expression]: ...
    def CopyToFullMatrix6(self) -> numpy.ndarray[object[6,6]]: ...
    def IsNaN(self) -> pydrake.symbolic.Formula: ...
    def IsPhysicallyValid(self) -> pydrake.symbolic.Formula: ...
    def MakeFromCentralInertia(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[Expression]) -> SpatialInertia_[Expression]: ...
    def SetNaN(self) -> None: ...
    def Shift(self, p_PQ_E: numpy.ndarray[object[3,1]]) -> SpatialInertia_[Expression]: ...
    def get_com(self) -> numpy.ndarray[object[3,1]]: ...
    def get_mass(self) -> pydrake.symbolic.Expression: ...
    def get_unit_inertia(self) -> UnitInertia_[Expression]: ...
    def __copy__(self) -> SpatialInertia_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> SpatialInertia_[Expression]: ...
    def __getstate__(self) -> tuple: ...
    def __iadd__(self, arg0: SpatialInertia_[Expression]) -> SpatialInertia_[Expression]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialAcceleration_[Expression]) -> pydrake.multibody.math.SpatialForce_[Expression]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialVelocity_[Expression]) -> pydrake.multibody.math.SpatialMomentum_[Expression]: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class _TemporaryName_N5drake9multibody14SpatialInertiaIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, mass: float, p_PScm_E: numpy.ndarray[numpy.float64[3,1]], G_SP_E: UnitInertia_[float], skip_validity_check: bool = ...) -> None: ...
    def CalcComMoment(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcRotationalInertia(self) -> RotationalInertia_[float]: ...
    def CopyToFullMatrix6(self) -> numpy.ndarray[numpy.float64[6,6]]: ...
    def IsNaN(self) -> bool: ...
    def IsPhysicallyValid(self) -> bool: ...
    def MakeFromCentralInertia(self, *args, **kwargs) -> Any: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[float]) -> SpatialInertia_[float]: ...
    def SetNaN(self) -> None: ...
    def Shift(self, p_PQ_E: numpy.ndarray[numpy.float64[3,1]]) -> SpatialInertia_[float]: ...
    def get_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_mass(self) -> float: ...
    def get_unit_inertia(self) -> UnitInertia_[float]: ...
    def __copy__(self) -> SpatialInertia_[float]: ...
    def __deepcopy__(self, arg0: dict) -> SpatialInertia_[float]: ...
    def __getstate__(self) -> tuple: ...
    def __iadd__(self, arg0: SpatialInertia_[float]) -> SpatialInertia_[float]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialAcceleration_[float]) -> pydrake.multibody.math.SpatialForce_[float]: ...
    @overload
    def __mul__(self, arg0: pydrake.multibody.math.SpatialVelocity_[float]) -> pydrake.multibody.math.SpatialMomentum_[float]: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class _TemporaryName_N5drake9multibody14UniversalJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[2,1]]: ...
    def get_angular_rates(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[2,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[AutoDiffXd], angles: numpy.ndarray[object[2,1]]) -> UniversalJoint_[AutoDiffXd]: ...
    def set_angular_rates(self, context: pydrake.systems.framework.Context_[AutoDiffXd], theta_dot: numpy.ndarray[object[2,1]]) -> UniversalJoint_[AutoDiffXd]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[2,1]]) -> None: ...

class _TemporaryName_N5drake9multibody14UniversalJointINS_8symbolic10ExpressionEEE(Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[2,1]]: ...
    def get_angular_rates(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[2,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[Expression], angles: numpy.ndarray[object[2,1]]) -> UniversalJoint_[Expression]: ...
    def set_angular_rates(self, context: pydrake.systems.framework.Context_[Expression], theta_dot: numpy.ndarray[object[2,1]]) -> UniversalJoint_[Expression]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[2,1]]) -> None: ...

class _TemporaryName_N5drake9multibody14UniversalJointIdEE(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], damping: float = ...) -> None: ...
    def damping(self) -> float: ...
    def get_angles(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_angular_rates(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def get_default_angles(self) -> numpy.ndarray[numpy.float64[2,1]]: ...
    def set_angles(self, context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[2,1]]) -> UniversalJoint_[float]: ...
    def set_angular_rates(self, context: pydrake.systems.framework.Context_[float], theta_dot: numpy.ndarray[numpy.float64[2,1]]) -> UniversalJoint_[float]: ...
    def set_default_angles(self, angles: numpy.ndarray[numpy.float64[2,1]]) -> None: ...
    def set_random_angles_distribution(self, angles: numpy.ndarray[object[2,1]]) -> None: ...

class _TemporaryName_N5drake9multibody15MultibodyForcesIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, nb: int, nv: int) -> None: ...
    def AddInForces(self, addend: MultibodyForces_[AutoDiffXd]) -> None: ...
    def SetZero(self) -> MultibodyForces_[AutoDiffXd]: ...
    def generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def mutable_generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def num_bodies(self) -> int: ...
    def num_velocities(self) -> int: ...
    def __copy__(self) -> MultibodyForces_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyForces_[AutoDiffXd]: ...

class _TemporaryName_N5drake9multibody15MultibodyForcesINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, plant) -> None: ...
    @overload
    def __init__(self, nb: int, nv: int) -> None: ...
    def AddInForces(self, addend: MultibodyForces_[Expression]) -> None: ...
    def SetZero(self) -> MultibodyForces_[Expression]: ...
    def generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def mutable_generalized_forces(self) -> numpy.ndarray[object[m,1]]: ...
    def num_bodies(self) -> int: ...
    def num_velocities(self) -> int: ...
    def __copy__(self) -> MultibodyForces_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyForces_[Expression]: ...

class _TemporaryName_N5drake9multibody15MultibodyForcesIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, plant) -> None: ...
    @overload
    def __init__(self, nb: int, nv: int) -> None: ...
    def AddInForces(self, addend: MultibodyForces_[float]) -> None: ...
    def SetZero(self) -> MultibodyForces_[float]: ...
    def generalized_forces(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def mutable_generalized_forces(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def num_bodies(self) -> int: ...
    def num_velocities(self) -> int: ...
    def __copy__(self) -> MultibodyForces_[float]: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyForces_[float]: ...

class _TemporaryName_N5drake9multibody15PrismaticSpringIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(ForceElement_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: PrismaticJoint_[AutoDiffXd], nominal_position: float, stiffness: float) -> None: ...
    def joint(self) -> PrismaticJoint_[AutoDiffXd]: ...
    def nominal_position(self) -> float: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody15PrismaticSpringINS_8symbolic10ExpressionEEE(ForceElement_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: PrismaticJoint_[Expression], nominal_position: float, stiffness: float) -> None: ...
    def joint(self) -> PrismaticJoint_[Expression]: ...
    def nominal_position(self) -> float: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody15PrismaticSpringIdEE(ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: PrismaticJoint_[float], nominal_position: float, stiffness: float) -> None: ...
    def joint(self) -> PrismaticJoint_[float]: ...
    def nominal_position(self) -> float: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody16FixedOffsetFrameIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Frame_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, P: Frame_[AutoDiffXd], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[ModelInstanceIndex] = ...) -> None: ...
    def GetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    @overload
    def SetPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd], X_PF: pydrake.math.RigidTransform_[AutoDiffXd]) -> None: ...
    @overload
    def SetPoseInBodyFrame(self) -> Any: ...
    def SetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd], X_PF: pydrake.math.RigidTransform_[AutoDiffXd]) -> None: ...

class _TemporaryName_N5drake9multibody16FixedOffsetFrameINS_8symbolic10ExpressionEEE(Frame_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, P: Frame_[Expression], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[ModelInstanceIndex] = ...) -> None: ...
    @overload
    def __init__(self, name: str, bodyB, X_BF: pydrake.math.RigidTransform_[float]) -> None: ...
    def GetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    @overload
    def SetPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[Expression], X_PF: pydrake.math.RigidTransform_[Expression]) -> None: ...
    @overload
    def SetPoseInBodyFrame(self) -> Any: ...
    def SetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[Expression], X_PF: pydrake.math.RigidTransform_[Expression]) -> None: ...

class _TemporaryName_N5drake9multibody16FixedOffsetFrameIdEE(Frame_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, name: str, P: Frame_[float], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[ModelInstanceIndex] = ...) -> None: ...
    @overload
    def __init__(self, name: str, bodyB, X_BF: pydrake.math.RigidTransform_[float]) -> None: ...
    def GetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    @overload
    def SetPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[float], X_PF: pydrake.math.RigidTransform_[float]) -> None: ...
    @overload
    def SetPoseInBodyFrame(self) -> Any: ...
    def SetPoseInParentFrame(self, context: pydrake.systems.framework.Context_[float], X_PF: pydrake.math.RigidTransform_[float]) -> None: ...

class _TemporaryName_N5drake9multibody17RotationalInertiaIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd, Ixy: pydrake.autodiffutils.AutoDiffXd, Ixz: pydrake.autodiffutils.AutoDiffXd, Iyz: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, mass: pydrake.autodiffutils.AutoDiffXd, p_PQ_E: numpy.ndarray[object[3,1]]) -> None: ...
    def CalcMaximumPossibleMomentOfInertia(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcPrincipalMomentsOfInertia(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CopyToFullMatrix3(self) -> numpy.ndarray[object[3,3]]: ...
    @overload
    def CouldBePhysicallyValid(self) -> bool: ...
    @overload
    def CouldBePhysicallyValid(self) -> Any: ...
    def IsNaN(self) -> bool: ...
    def IsNearlyEqualTo(self, other: RotationalInertia_[AutoDiffXd], precision: float) -> bool: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[AutoDiffXd]) -> RotationalInertia_[AutoDiffXd]: ...
    def SetToNaN(self) -> None: ...
    def SetZero(self) -> None: ...
    def ShiftFromCenterOfMass(self, mass: pydrake.autodiffutils.AutoDiffXd, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_[AutoDiffXd]: ...
    def ShiftToCenterOfMass(self, mass: pydrake.autodiffutils.AutoDiffXd, p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_[AutoDiffXd]: ...
    def ShiftToThenAwayFromCenterOfMass(self, mass: pydrake.autodiffutils.AutoDiffXd, p_PBcm_E: numpy.ndarray[object[3,1]], p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_[AutoDiffXd]: ...
    def Trace(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    @overload
    def cols(self) -> int: ...
    @overload
    def cols(self) -> Any: ...
    def get_moments(self) -> numpy.ndarray[object[3,1]]: ...
    def get_products(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def rows(self) -> int: ...
    @overload
    def rows(self) -> Any: ...
    def __add__(self, arg0: RotationalInertia_[AutoDiffXd]) -> RotationalInertia_[AutoDiffXd]: ...
    def __copy__(self) -> RotationalInertia_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> RotationalInertia_[AutoDiffXd]: ...
    def __getitem__(self, arg0: tuple) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __iadd__(self, arg0: RotationalInertia_[AutoDiffXd]) -> RotationalInertia_[AutoDiffXd]: ...
    def __imul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_[AutoDiffXd]: ...
    def __isub__(self, arg0: RotationalInertia_[AutoDiffXd]) -> RotationalInertia_[AutoDiffXd]: ...
    def __itruediv__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_[AutoDiffXd]: ...
    @overload
    def __mul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_[AutoDiffXd]: ...
    @overload
    def __mul__(self, arg0: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def __rmul__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_[AutoDiffXd]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    def __sub__(self, arg0: RotationalInertia_[AutoDiffXd]) -> RotationalInertia_[AutoDiffXd]: ...
    def __truediv__(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> RotationalInertia_[AutoDiffXd]: ...

class _TemporaryName_N5drake9multibody17RotationalInertiaINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression, Ixy: pydrake.symbolic.Expression, Ixz: pydrake.symbolic.Expression, Iyz: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, mass: pydrake.symbolic.Expression, p_PQ_E: numpy.ndarray[object[3,1]]) -> None: ...
    def CalcMaximumPossibleMomentOfInertia(self) -> pydrake.symbolic.Expression: ...
    def CalcPrincipalMomentsOfInertia(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CopyToFullMatrix3(self) -> numpy.ndarray[object[3,3]]: ...
    @overload
    def CouldBePhysicallyValid(self) -> pydrake.symbolic.Formula: ...
    @overload
    def CouldBePhysicallyValid(self) -> Any: ...
    def IsNaN(self) -> pydrake.symbolic.Formula: ...
    def IsNearlyEqualTo(self, other: RotationalInertia_[Expression], precision: float) -> pydrake.symbolic.Formula: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[Expression]) -> RotationalInertia_[Expression]: ...
    def SetToNaN(self) -> None: ...
    def SetZero(self) -> None: ...
    def ShiftFromCenterOfMass(self, mass: pydrake.symbolic.Expression, p_BcmQ_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_[Expression]: ...
    def ShiftToCenterOfMass(self, mass: pydrake.symbolic.Expression, p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_[Expression]: ...
    def ShiftToThenAwayFromCenterOfMass(self, mass: pydrake.symbolic.Expression, p_PBcm_E: numpy.ndarray[object[3,1]], p_QBcm_E: numpy.ndarray[object[3,1]]) -> RotationalInertia_[Expression]: ...
    def Trace(self) -> pydrake.symbolic.Expression: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    @overload
    def cols(self) -> int: ...
    @overload
    def cols(self) -> Any: ...
    def get_moments(self) -> numpy.ndarray[object[3,1]]: ...
    def get_products(self) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def rows(self) -> int: ...
    @overload
    def rows(self) -> Any: ...
    def __add__(self, arg0: RotationalInertia_[Expression]) -> RotationalInertia_[Expression]: ...
    def __copy__(self) -> RotationalInertia_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> RotationalInertia_[Expression]: ...
    def __getitem__(self, arg0: tuple) -> pydrake.symbolic.Expression: ...
    def __getstate__(self) -> numpy.ndarray[object[3,3]]: ...
    def __iadd__(self, arg0: RotationalInertia_[Expression]) -> RotationalInertia_[Expression]: ...
    def __imul__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_[Expression]: ...
    def __isub__(self, arg0: RotationalInertia_[Expression]) -> RotationalInertia_[Expression]: ...
    def __itruediv__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_[Expression]: ...
    @overload
    def __mul__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_[Expression]: ...
    @overload
    def __mul__(self, arg0: numpy.ndarray[object[3,1]]) -> numpy.ndarray[object[3,1]]: ...
    def __rmul__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_[Expression]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    def __sub__(self, arg0: RotationalInertia_[Expression]) -> RotationalInertia_[Expression]: ...
    def __truediv__(self, arg0: pydrake.symbolic.Expression) -> RotationalInertia_[Expression]: ...

class _TemporaryName_N5drake9multibody17RotationalInertiaIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float) -> None: ...
    @overload
    def __init__(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None: ...
    @overload
    def __init__(self, mass: float, p_PQ_E: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcMaximumPossibleMomentOfInertia(self) -> float: ...
    def CalcPrincipalMomentsOfInertia(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CopyToFullMatrix3(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    @overload
    def CouldBePhysicallyValid(self) -> bool: ...
    @overload
    def CouldBePhysicallyValid(self) -> Any: ...
    def IsNaN(self) -> bool: ...
    def IsNearlyEqualTo(self, other: RotationalInertia_[float], precision: float) -> bool: ...
    def ReExpress(self, R_AE: pydrake.math.RotationMatrix_[float]) -> RotationalInertia_[float]: ...
    def SetToNaN(self) -> None: ...
    def SetZero(self) -> None: ...
    def ShiftFromCenterOfMass(self, mass: float, p_BcmQ_E: numpy.ndarray[numpy.float64[3,1]]) -> RotationalInertia_[float]: ...
    def ShiftToCenterOfMass(self, mass: float, p_QBcm_E: numpy.ndarray[numpy.float64[3,1]]) -> RotationalInertia_[float]: ...
    def ShiftToThenAwayFromCenterOfMass(self, mass: float, p_PBcm_E: numpy.ndarray[numpy.float64[3,1]], p_QBcm_E: numpy.ndarray[numpy.float64[3,1]]) -> RotationalInertia_[float]: ...
    def Trace(self) -> float: ...
    def TriaxiallySymmetric(self, *args, **kwargs) -> Any: ...
    @overload
    def cols(self) -> int: ...
    @overload
    def cols(self) -> Any: ...
    def get_moments(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_products(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def rows(self) -> int: ...
    @overload
    def rows(self) -> Any: ...
    def __add__(self, arg0: RotationalInertia_[float]) -> RotationalInertia_[float]: ...
    def __copy__(self) -> RotationalInertia_[float]: ...
    def __deepcopy__(self, arg0: dict) -> RotationalInertia_[float]: ...
    def __getitem__(self, arg0: tuple) -> float: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def __iadd__(self, arg0: RotationalInertia_[float]) -> RotationalInertia_[float]: ...
    def __imul__(self, arg0: float) -> RotationalInertia_[float]: ...
    def __isub__(self, arg0: RotationalInertia_[float]) -> RotationalInertia_[float]: ...
    def __itruediv__(self, arg0: float) -> RotationalInertia_[float]: ...
    @overload
    def __mul__(self, arg0: float) -> RotationalInertia_[float]: ...
    @overload
    def __mul__(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __rmul__(self, arg0: float) -> RotationalInertia_[float]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    def __sub__(self, arg0: RotationalInertia_[float]) -> RotationalInertia_[float]: ...
    def __truediv__(self, arg0: float) -> RotationalInertia_[float]: ...

class _TemporaryName_N5drake9multibody18LinearSpringDamperIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(ForceElement_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA: Body_[AutoDiffXd], p_AP: numpy.ndarray[numpy.float64[3,1]], bodyB: Body_[AutoDiffXd], p_BQ: numpy.ndarray[numpy.float64[3,1]], free_length: float, stiffness: float, damping: float) -> None: ...
    def bodyA(self) -> Body_[AutoDiffXd]: ...
    def bodyB(self) -> Body_[AutoDiffXd]: ...
    def damping(self) -> float: ...
    def free_length(self) -> float: ...
    def p_AP(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def p_BQ(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody18LinearSpringDamperINS_8symbolic10ExpressionEEE(ForceElement_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA: Body_[Expression], p_AP: numpy.ndarray[numpy.float64[3,1]], bodyB: Body_[Expression], p_BQ: numpy.ndarray[numpy.float64[3,1]], free_length: float, stiffness: float, damping: float) -> None: ...
    def bodyA(self) -> Body_[Expression]: ...
    def bodyB(self) -> Body_[Expression]: ...
    def damping(self) -> float: ...
    def free_length(self) -> float: ...
    def p_AP(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def p_BQ(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody18LinearSpringDamperIdEE(ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA: Body_[float], p_AP: numpy.ndarray[numpy.float64[3,1]], bodyB: Body_[float], p_BQ: numpy.ndarray[numpy.float64[3,1]], free_length: float, stiffness: float, damping: float) -> None: ...
    def bodyA(self) -> Body_[float]: ...
    def bodyB(self) -> Body_[float]: ...
    def damping(self) -> float: ...
    def free_length(self) -> float: ...
    def p_AP(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def p_BQ(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def stiffness(self) -> float: ...

class _TemporaryName_N5drake9multibody23QuaternionFloatingJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[AutoDiffXd], frame_on_child: Frame_[AutoDiffXd], angular_damping: float = ..., translational_damping: float = ...) -> None: ...
    def SetDefaultPose(self, X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def SetFromRotationMatrix(self, context: pydrake.systems.framework.Context_[AutoDiffXd], R_FM: pydrake.math.RotationMatrix_[AutoDiffXd]) -> QuaternionFloatingJoint_[AutoDiffXd]: ...
    def angular_damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def get_default_pose(self) -> pydrake.math.RigidTransform_[float]: ...
    def get_default_position(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_quaternion(self) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def get_pose(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def get_position(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def get_quaternion(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], w_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_[AutoDiffXd]: ...
    def set_default_position(self, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_default_quaternion(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[float]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[AutoDiffXd], X_FM: pydrake.math.RigidTransform_[AutoDiffXd]) -> QuaternionFloatingJoint_[AutoDiffXd]: ...
    def set_position(self, context: pydrake.systems.framework.Context_[AutoDiffXd], p_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_[AutoDiffXd]: ...
    def set_quaternion(self, context: pydrake.systems.framework.Context_[AutoDiffXd], q_FM: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -> QuaternionFloatingJoint_[AutoDiffXd]: ...
    def set_random_position_distribution(self, p_FM: numpy.ndarray[object[3,1]]) -> None: ...
    def set_random_quaternion_distribution(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[Expression]) -> None: ...
    def set_random_quaternion_distribution_to_uniform(self) -> None: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], v_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_[AutoDiffXd]: ...
    def translational_damping(self) -> float: ...

class _TemporaryName_N5drake9multibody23QuaternionFloatingJointINS_8symbolic10ExpressionEEE(Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[Expression], frame_on_child: Frame_[Expression], angular_damping: float = ..., translational_damping: float = ...) -> None: ...
    def SetDefaultPose(self, X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def SetFromRotationMatrix(self, context: pydrake.systems.framework.Context_[Expression], R_FM: pydrake.math.RotationMatrix_[Expression]) -> QuaternionFloatingJoint_[Expression]: ...
    def angular_damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def get_default_pose(self) -> pydrake.math.RigidTransform_[float]: ...
    def get_default_position(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_quaternion(self) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def get_pose(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def get_position(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def get_quaternion(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.common.eigen_geometry.Quaternion_[Expression]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[Expression], w_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_[Expression]: ...
    def set_default_position(self, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_default_quaternion(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[float]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[Expression], X_FM: pydrake.math.RigidTransform_[Expression]) -> QuaternionFloatingJoint_[Expression]: ...
    def set_position(self, context: pydrake.systems.framework.Context_[Expression], p_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_[Expression]: ...
    def set_quaternion(self, context: pydrake.systems.framework.Context_[Expression], q_FM: pydrake.common.eigen_geometry.Quaternion_[Expression]) -> QuaternionFloatingJoint_[Expression]: ...
    def set_random_position_distribution(self, p_FM: numpy.ndarray[object[3,1]]) -> None: ...
    def set_random_quaternion_distribution(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[Expression]) -> None: ...
    def set_random_quaternion_distribution_to_uniform(self) -> None: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[Expression], v_FM: numpy.ndarray[object[3,1]]) -> QuaternionFloatingJoint_[Expression]: ...
    def translational_damping(self) -> float: ...

class _TemporaryName_N5drake9multibody23QuaternionFloatingJointIdEE(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent: Frame_[float], frame_on_child: Frame_[float], angular_damping: float = ..., translational_damping: float = ...) -> None: ...
    def SetDefaultPose(self, X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def SetFromRotationMatrix(self, context: pydrake.systems.framework.Context_[float], R_FM: pydrake.math.RotationMatrix_[float]) -> QuaternionFloatingJoint_[float]: ...
    def angular_damping(self) -> float: ...
    def get_angular_velocity(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_pose(self) -> pydrake.math.RigidTransform_[float]: ...
    def get_default_position(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_default_quaternion(self) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def get_pose(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def get_position(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def get_quaternion(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def get_translational_velocity(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_angular_velocity(self, context: pydrake.systems.framework.Context_[float], w_FM: numpy.ndarray[numpy.float64[3,1]]) -> QuaternionFloatingJoint_[float]: ...
    def set_default_position(self, p_FM: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_default_quaternion(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[float]) -> None: ...
    def set_pose(self, context: pydrake.systems.framework.Context_[float], X_FM: pydrake.math.RigidTransform_[float]) -> QuaternionFloatingJoint_[float]: ...
    def set_position(self, context: pydrake.systems.framework.Context_[float], p_FM: numpy.ndarray[numpy.float64[3,1]]) -> QuaternionFloatingJoint_[float]: ...
    def set_quaternion(self, context: pydrake.systems.framework.Context_[float], q_FM: pydrake.common.eigen_geometry.Quaternion_[float]) -> QuaternionFloatingJoint_[float]: ...
    def set_random_position_distribution(self, p_FM: numpy.ndarray[object[3,1]]) -> None: ...
    def set_random_quaternion_distribution(self, q_FM: pydrake.common.eigen_geometry.Quaternion_[Expression]) -> None: ...
    def set_random_quaternion_distribution_to_uniform(self) -> None: ...
    def set_translational_velocity(self, context: pydrake.systems.framework.Context_[float], v_FM: numpy.ndarray[numpy.float64[3,1]]) -> QuaternionFloatingJoint_[float]: ...
    def translational_damping(self) -> float: ...

class _TemporaryName_N5drake9multibody25LinearBushingRollPitchYawIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(ForceElement_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, frameA: Frame_[AutoDiffXd], frameC: Frame_[AutoDiffXd], torque_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], torque_damping_constants: numpy.ndarray[numpy.float64[3,1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], force_damping_constants: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcBushingSpatialForceOnFrameA(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.multibody.math.SpatialForce_[AutoDiffXd]: ...
    def CalcBushingSpatialForceOnFrameC(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.multibody.math.SpatialForce_[AutoDiffXd]: ...
    def GetForceDampingConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def GetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def SetForceDampingConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd], force_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd], force_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd], torque_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[AutoDiffXd], torque_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def force_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def force_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def frameA(self) -> Frame_[AutoDiffXd]: ...
    def frameC(self) -> Frame_[AutoDiffXd]: ...
    def link0(self) -> Body_[AutoDiffXd]: ...
    def link1(self) -> Body_[AutoDiffXd]: ...
    def torque_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def torque_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class _TemporaryName_N5drake9multibody25LinearBushingRollPitchYawINS_8symbolic10ExpressionEEE(ForceElement_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, frameA: Frame_[Expression], frameC: Frame_[Expression], torque_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], torque_damping_constants: numpy.ndarray[numpy.float64[3,1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], force_damping_constants: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcBushingSpatialForceOnFrameA(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.multibody.math.SpatialForce_[Expression]: ...
    def CalcBushingSpatialForceOnFrameC(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.multibody.math.SpatialForce_[Expression]: ...
    def GetForceDampingConstants(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def GetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def GetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def SetForceDampingConstants(self, context: pydrake.systems.framework.Context_[Expression], force_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[Expression], force_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[Expression], torque_damping: numpy.ndarray[object[3,1]]) -> None: ...
    def SetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[Expression], torque_stiffness: numpy.ndarray[object[3,1]]) -> None: ...
    def force_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def force_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def frameA(self) -> Frame_[Expression]: ...
    def frameC(self) -> Frame_[Expression]: ...
    def link0(self) -> Body_[Expression]: ...
    def link1(self) -> Body_[Expression]: ...
    def torque_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def torque_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class _TemporaryName_N5drake9multibody25LinearBushingRollPitchYawIdEE(ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, frameA: Frame_[float], frameC: Frame_[float], torque_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], torque_damping_constants: numpy.ndarray[numpy.float64[3,1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3,1]], force_damping_constants: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcBushingSpatialForceOnFrameA(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialForce_[float]: ...
    def CalcBushingSpatialForceOnFrameC(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialForce_[float]: ...
    def GetForceDampingConstants(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def SetForceDampingConstants(self, context: pydrake.systems.framework.Context_[float], force_damping: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetForceStiffnessConstants(self, context: pydrake.systems.framework.Context_[float], force_stiffness: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetTorqueDampingConstants(self, context: pydrake.systems.framework.Context_[float], torque_damping: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetTorqueStiffnessConstants(self, context: pydrake.systems.framework.Context_[float], torque_stiffness: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def force_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def force_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def frameA(self) -> Frame_[float]: ...
    def frameC(self) -> Frame_[float]: ...
    def link0(self) -> Body_[float]: ...
    def link1(self) -> Body_[float]: ...
    def torque_damping_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def torque_stiffness_constants(self) -> numpy.ndarray[numpy.float64[3,1]]: ...

class _TemporaryName_N5drake9multibody26UniformGravityFieldElementIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(ForceElement_[AutoDiffXd]):
    kDefaultStrength: ClassVar[float] = ...  # read-only
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, g_W: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    def gravity_vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_gravity_vector(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class _TemporaryName_N5drake9multibody26UniformGravityFieldElementINS_8symbolic10ExpressionEEE(ForceElement_[Expression]):
    kDefaultStrength: ClassVar[float] = ...  # read-only
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, g_W: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    def gravity_vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_gravity_vector(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class _TemporaryName_N5drake9multibody26UniformGravityFieldElementIdEE(ForceElement_[float]):
    kDefaultStrength: ClassVar[float] = ...  # read-only
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, g_W: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def gravity_vector(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def set_gravity_vector(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...

class _TemporaryName_N5drake9multibody4BodyIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInForce(self, *args, **kwargs) -> Any: ...
    def AddInForceInWorld(self, *args, **kwargs) -> Any: ...
    def CalcCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def CalcSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def EvalPoseInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def EvalSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]: ...
    def EvalSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]: ...
    def GetForceInWorld(self, *args, **kwargs) -> Any: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    def body_frame(self) -> BodyFrame_[AutoDiffXd]: ...
    @overload
    def default_mass(self) -> float: ...
    @overload
    def default_mass(self) -> Any: ...
    def floating_position_suffix(self, arg0: int) -> str: ...
    def floating_positions_start(self) -> int: ...
    def floating_velocities_start(self) -> int: ...
    def floating_velocity_suffix(self, arg0: int) -> str: ...
    def get_mass(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_num_flexible_positions(self) -> int: ...
    def get_num_flexible_velocities(self) -> int: ...
    def has_quaternion_dofs(self) -> bool: ...
    def index(self) -> BodyIndex: ...
    def is_floating(self) -> bool: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class _TemporaryName_N5drake9multibody4BodyINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInForce(self, context: pydrake.systems.framework.Context_[Expression], p_BP_E: numpy.ndarray[object[3,1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[Expression], frame_E: Frame_[Expression], forces) -> None: ...
    def AddInForceInWorld(self, context: pydrake.systems.framework.Context_[Expression], F_Bo_W: pydrake.multibody.math.SpatialForce_[Expression], forces) -> None: ...
    def CalcCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def CalcSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def EvalPoseInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def EvalSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.multibody.math.SpatialAcceleration_[Expression]: ...
    def EvalSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.multibody.math.SpatialVelocity_[Expression]: ...
    def GetForceInWorld(self, context: pydrake.systems.framework.Context_[Expression], forces) -> pydrake.multibody.math.SpatialForce_[Expression]: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[Expression]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[Expression]) -> None: ...
    def body_frame(self) -> BodyFrame_[Expression]: ...
    @overload
    def default_mass(self) -> float: ...
    @overload
    def default_mass(self) -> Any: ...
    def floating_position_suffix(self, arg0: int) -> str: ...
    def floating_positions_start(self) -> int: ...
    def floating_velocities_start(self) -> int: ...
    def floating_velocity_suffix(self, arg0: int) -> str: ...
    def get_mass(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def get_num_flexible_positions(self) -> int: ...
    def get_num_flexible_velocities(self) -> int: ...
    def has_quaternion_dofs(self) -> bool: ...
    def index(self) -> BodyIndex: ...
    def is_floating(self) -> bool: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[Expression]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class _TemporaryName_N5drake9multibody4BodyIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInForce(self, context: pydrake.systems.framework.Context_[float], p_BP_E: numpy.ndarray[numpy.float64[3,1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[float], frame_E: Frame_[float], forces) -> None: ...
    def AddInForceInWorld(self, context: pydrake.systems.framework.Context_[float], F_Bo_W: pydrake.multibody.math.SpatialForce_[float], forces) -> None: ...
    def CalcCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def EvalPoseInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def EvalSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def EvalSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def GetForceInWorld(self, context: pydrake.systems.framework.Context_[float], forces) -> pydrake.multibody.math.SpatialForce_[float]: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def body_frame(self) -> BodyFrame_[float]: ...
    @overload
    def default_mass(self) -> float: ...
    @overload
    def default_mass(self) -> Any: ...
    def floating_position_suffix(self, arg0: int) -> str: ...
    def floating_positions_start(self) -> int: ...
    def floating_velocities_start(self) -> int: ...
    def floating_velocity_suffix(self, arg0: int) -> str: ...
    def get_mass(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def get_num_flexible_positions(self) -> int: ...
    def get_num_flexible_velocities(self) -> int: ...
    def has_quaternion_dofs(self) -> bool: ...
    def index(self) -> BodyIndex: ...
    def is_floating(self) -> bool: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[float]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class _TemporaryName_N5drake9multibody5FrameIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def CalcAngularVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], measured_in_frame: Frame_[AutoDiffXd], expressed_in_frame: Frame_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def CalcOffsetPoseInBody(self, context: pydrake.systems.framework.Context_[AutoDiffXd], X_FQ: pydrake.math.RigidTransform_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def CalcOffsetRotationMatrixInBody(self, context: pydrake.systems.framework.Context_[AutoDiffXd], R_FQ: pydrake.math.RotationMatrix_[AutoDiffXd]) -> pydrake.math.RotationMatrix_[AutoDiffXd]: ...
    def CalcPose(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_M: Frame_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def CalcPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def CalcPoseInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def CalcRelativeSpatialAcceleration(self, context: pydrake.systems.framework.Context_[AutoDiffXd], other_frame: Frame_[AutoDiffXd], measured_in_frame: Frame_[AutoDiffXd], expressed_in_frame: Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]: ...
    def CalcRelativeSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd], other_frame: Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]: ...
    def CalcRelativeSpatialVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], other_frame: Frame_[AutoDiffXd], measured_in_frame: Frame_[AutoDiffXd], expressed_in_frame: Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]: ...
    def CalcRelativeSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd], other_frame: Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]: ...
    def CalcRotationMatrix(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_M: Frame_[AutoDiffXd]) -> pydrake.math.RotationMatrix_[AutoDiffXd]: ...
    def CalcRotationMatrixInBodyFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RotationMatrix_[AutoDiffXd]: ...
    def CalcRotationMatrixInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.math.RotationMatrix_[AutoDiffXd]: ...
    def CalcSpatialAcceleration(self, context: pydrake.systems.framework.Context_[AutoDiffXd], measured_in_frame: Frame_[AutoDiffXd], expressed_in_frame: Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]: ...
    def CalcSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]: ...
    def CalcSpatialVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_M: Frame_[AutoDiffXd], frame_E: Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]: ...
    def CalcSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]: ...
    def EvalAngularVelocityInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def GetFixedOffsetPoseInBody(self, X_FQ: pydrake.math.RigidTransform_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def GetFixedRotationMatrixInBody(self, R_FQ: pydrake.math.RotationMatrix_[AutoDiffXd]) -> pydrake.math.RotationMatrix_[AutoDiffXd]: ...
    def GetFixedRotationMatrixInBodyFrame(self) -> pydrake.math.RotationMatrix_[AutoDiffXd]: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def body(self, *args, **kwargs) -> Any: ...
    def index(self) -> FrameIndex: ...
    def is_body_frame(self) -> bool: ...
    def is_world_frame(self) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class _TemporaryName_N5drake9multibody5FrameINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def CalcAngularVelocity(self, context: pydrake.systems.framework.Context_[Expression], measured_in_frame: Frame_[Expression], expressed_in_frame: Frame_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def CalcOffsetPoseInBody(self, context: pydrake.systems.framework.Context_[Expression], X_FQ: pydrake.math.RigidTransform_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def CalcOffsetRotationMatrixInBody(self, context: pydrake.systems.framework.Context_[Expression], R_FQ: pydrake.math.RotationMatrix_[Expression]) -> pydrake.math.RotationMatrix_[Expression]: ...
    def CalcPose(self, context: pydrake.systems.framework.Context_[Expression], frame_M: Frame_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def CalcPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def CalcPoseInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def CalcRelativeSpatialAcceleration(self, context: pydrake.systems.framework.Context_[Expression], other_frame: Frame_[Expression], measured_in_frame: Frame_[Expression], expressed_in_frame: Frame_[Expression]) -> pydrake.multibody.math.SpatialAcceleration_[Expression]: ...
    def CalcRelativeSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[Expression], other_frame: Frame_[Expression]) -> pydrake.multibody.math.SpatialAcceleration_[Expression]: ...
    def CalcRelativeSpatialVelocity(self, context: pydrake.systems.framework.Context_[Expression], other_frame: Frame_[Expression], measured_in_frame: Frame_[Expression], expressed_in_frame: Frame_[Expression]) -> pydrake.multibody.math.SpatialVelocity_[Expression]: ...
    def CalcRelativeSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[Expression], other_frame: Frame_[Expression]) -> pydrake.multibody.math.SpatialVelocity_[Expression]: ...
    def CalcRotationMatrix(self, context: pydrake.systems.framework.Context_[Expression], frame_M: Frame_[Expression]) -> pydrake.math.RotationMatrix_[Expression]: ...
    def CalcRotationMatrixInBodyFrame(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RotationMatrix_[Expression]: ...
    def CalcRotationMatrixInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.math.RotationMatrix_[Expression]: ...
    def CalcSpatialAcceleration(self, context: pydrake.systems.framework.Context_[Expression], measured_in_frame: Frame_[Expression], expressed_in_frame: Frame_[Expression]) -> pydrake.multibody.math.SpatialAcceleration_[Expression]: ...
    def CalcSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.multibody.math.SpatialAcceleration_[Expression]: ...
    def CalcSpatialVelocity(self, context: pydrake.systems.framework.Context_[Expression], frame_M: Frame_[Expression], frame_E: Frame_[Expression]) -> pydrake.multibody.math.SpatialVelocity_[Expression]: ...
    def CalcSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.multibody.math.SpatialVelocity_[Expression]: ...
    def EvalAngularVelocityInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def GetFixedOffsetPoseInBody(self, X_FQ: pydrake.math.RigidTransform_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[Expression]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[Expression]: ...
    def GetFixedRotationMatrixInBody(self, R_FQ: pydrake.math.RotationMatrix_[Expression]) -> pydrake.math.RotationMatrix_[Expression]: ...
    def GetFixedRotationMatrixInBodyFrame(self) -> pydrake.math.RotationMatrix_[Expression]: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def body(self, *args, **kwargs) -> Any: ...
    def index(self) -> FrameIndex: ...
    def is_body_frame(self) -> bool: ...
    def is_world_frame(self) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class _TemporaryName_N5drake9multibody5FrameIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def CalcAngularVelocity(self, context: pydrake.systems.framework.Context_[float], measured_in_frame: Frame_[float], expressed_in_frame: Frame_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcOffsetPoseInBody(self, context: pydrake.systems.framework.Context_[float], X_FQ: pydrake.math.RigidTransform_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcOffsetRotationMatrixInBody(self, context: pydrake.systems.framework.Context_[float], R_FQ: pydrake.math.RotationMatrix_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def CalcPose(self, context: pydrake.systems.framework.Context_[float], frame_M: Frame_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcPoseInBodyFrame(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcPoseInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcRelativeSpatialAcceleration(self, context: pydrake.systems.framework.Context_[float], other_frame: Frame_[float], measured_in_frame: Frame_[float], expressed_in_frame: Frame_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcRelativeSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[float], other_frame: Frame_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcRelativeSpatialVelocity(self, context: pydrake.systems.framework.Context_[float], other_frame: Frame_[float], measured_in_frame: Frame_[float], expressed_in_frame: Frame_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def CalcRelativeSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[float], other_frame: Frame_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def CalcRotationMatrix(self, context: pydrake.systems.framework.Context_[float], frame_M: Frame_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def CalcRotationMatrixInBodyFrame(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def CalcRotationMatrixInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def CalcSpatialAcceleration(self, context: pydrake.systems.framework.Context_[float], measured_in_frame: Frame_[float], expressed_in_frame: Frame_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcSpatialAccelerationInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcSpatialVelocity(self, context: pydrake.systems.framework.Context_[float], frame_M: Frame_[float], frame_E: Frame_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def CalcSpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    def EvalAngularVelocityInWorld(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def GetFixedOffsetPoseInBody(self, X_FQ: pydrake.math.RigidTransform_[float]) -> pydrake.math.RigidTransform_[float]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[float]: ...
    @overload
    def GetFixedPoseInBodyFrame(self) -> pydrake.math.RigidTransform_[float]: ...
    def GetFixedRotationMatrixInBody(self, R_FQ: pydrake.math.RotationMatrix_[float]) -> pydrake.math.RotationMatrix_[float]: ...
    def GetFixedRotationMatrixInBodyFrame(self) -> pydrake.math.RotationMatrix_[float]: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def body(self, *args, **kwargs) -> Any: ...
    def index(self) -> FrameIndex: ...
    def is_body_frame(self) -> bool: ...
    def is_world_frame(self) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...

class _TemporaryName_N5drake9multibody5JointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInDamping(self, *args, **kwargs) -> Any: ...
    def AddInOneForce(self, *args, **kwargs) -> Any: ...
    def GetOnePosition(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def GetOneVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    def acceleration_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def acceleration_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def child_body(self) -> Body_[AutoDiffXd]: ...
    def default_positions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def frame_on_child(self) -> Frame_[AutoDiffXd]: ...
    def frame_on_parent(self) -> Frame_[AutoDiffXd]: ...
    def index(self) -> JointIndex: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_positions(self) -> int: ...
    def num_velocities(self) -> int: ...
    def parent_body(self) -> Body_[AutoDiffXd]: ...
    def position_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def position_start(self) -> int: ...
    def position_suffix(self, arg0: int) -> str: ...
    def position_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def set_acceleration_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_default_positions(self, default_positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_position_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_velocity_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def type_name(self) -> str: ...
    def velocity_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def velocity_start(self) -> int: ...
    def velocity_suffix(self, arg0: int) -> str: ...
    def velocity_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...

class _TemporaryName_N5drake9multibody5JointINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInDamping(self, context: pydrake.systems.framework.Context_[Expression], forces) -> None: ...
    def AddInOneForce(self, context: pydrake.systems.framework.Context_[Expression], joint_dof: int, joint_tau: pydrake.symbolic.Expression, forces) -> None: ...
    def GetOnePosition(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def GetOneVelocity(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[Expression]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[Expression]) -> None: ...
    def acceleration_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def acceleration_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def child_body(self) -> Body_[Expression]: ...
    def default_positions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def frame_on_child(self) -> Frame_[Expression]: ...
    def frame_on_parent(self) -> Frame_[Expression]: ...
    def index(self) -> JointIndex: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[Expression]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_positions(self) -> int: ...
    def num_velocities(self) -> int: ...
    def parent_body(self) -> Body_[Expression]: ...
    def position_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def position_start(self) -> int: ...
    def position_suffix(self, arg0: int) -> str: ...
    def position_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def set_acceleration_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_default_positions(self, default_positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_position_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_velocity_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def type_name(self) -> str: ...
    def velocity_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def velocity_start(self) -> int: ...
    def velocity_suffix(self, arg0: int) -> str: ...
    def velocity_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...

class _TemporaryName_N5drake9multibody5JointIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def AddInDamping(self, context: pydrake.systems.framework.Context_[float], forces) -> None: ...
    def AddInOneForce(self, context: pydrake.systems.framework.Context_[float], joint_dof: int, joint_tau: float, forces) -> None: ...
    def GetOnePosition(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def GetOneVelocity(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    def GetParentPlant(self, *args, **kwargs) -> Any: ...
    def Lock(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def Unlock(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def acceleration_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def acceleration_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def child_body(self) -> Body_[float]: ...
    def default_positions(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def frame_on_child(self) -> Frame_[float]: ...
    def frame_on_parent(self) -> Frame_[float]: ...
    def index(self) -> JointIndex: ...
    def is_locked(self, context: pydrake.systems.framework.Context_[float]) -> bool: ...
    def model_instance(self) -> ModelInstanceIndex: ...
    def name(self) -> str: ...
    def num_positions(self) -> int: ...
    def num_velocities(self) -> int: ...
    def parent_body(self) -> Body_[float]: ...
    def position_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def position_start(self) -> int: ...
    def position_suffix(self, arg0: int) -> str: ...
    def position_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def set_acceleration_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_default_positions(self, default_positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_position_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_velocity_limits(self, lower_limits: numpy.ndarray[numpy.float64[m,1]], upper_limits: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def type_name(self) -> str: ...
    def velocity_lower_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def velocity_start(self) -> int: ...
    def velocity_suffix(self, arg0: int) -> str: ...
    def velocity_upper_limits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...

class _TemporaryName_N5drake9multibody9BodyFrameIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Frame_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class _TemporaryName_N5drake9multibody9BodyFrameINS_8symbolic10ExpressionEEE(Frame_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class _TemporaryName_N5drake9multibody9BodyFrameIdEE(Frame_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class _TemporaryName_N5drake9multibody9DoorHingeIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(ForceElement_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[AutoDiffXd], config: DoorHingeConfig) -> None: ...
    def CalcHingeFrictionalTorque(self, angular_rate: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcHingeSpringTorque(self, angle: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def CalcHingeTorque(self, angle: pydrake.autodiffutils.AutoDiffXd, angular_rate: pydrake.autodiffutils.AutoDiffXd) -> pydrake.autodiffutils.AutoDiffXd: ...
    def config(self) -> DoorHingeConfig: ...
    def joint(self) -> RevoluteJoint_[AutoDiffXd]: ...

class _TemporaryName_N5drake9multibody9DoorHingeINS_8symbolic10ExpressionEEE(ForceElement_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[Expression], config: DoorHingeConfig) -> None: ...
    def CalcHingeFrictionalTorque(self, angular_rate: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def CalcHingeSpringTorque(self, angle: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def CalcHingeTorque(self, angle: pydrake.symbolic.Expression, angular_rate: pydrake.symbolic.Expression) -> pydrake.symbolic.Expression: ...
    def config(self) -> DoorHingeConfig: ...
    def joint(self) -> RevoluteJoint_[Expression]: ...

class _TemporaryName_N5drake9multibody9DoorHingeIdEE(ForceElement_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, joint: RevoluteJoint_[float], config: DoorHingeConfig) -> None: ...
    def CalcHingeFrictionalTorque(self, angular_rate: float) -> float: ...
    def CalcHingeSpringTorque(self, angle: float) -> float: ...
    def CalcHingeTorque(self, angle: float, angular_rate: float) -> float: ...
    def config(self) -> DoorHingeConfig: ...
    def joint(self) -> RevoluteJoint_[float]: ...

class _TemporaryName_N5drake9multibody9RigidBodyIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Body_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_name: str, M_BBo_B: SpatialInertia_[float]) -> None: ...
    @overload
    def __init__(self, body_name: str, model_instance: ModelInstanceIndex, M_BBo_B: SpatialInertia_[float]) -> None: ...
    def SetCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[AutoDiffXd], com: numpy.ndarray[object[3,1]]) -> None: ...
    def SetMass(self, context: pydrake.systems.framework.Context_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def SetSpatialInertiaInBodyFrame(self, *args, **kwargs) -> Any: ...
    def default_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def default_mass(self) -> float: ...
    def default_rotational_inertia(self) -> RotationalInertia_[float]: ...
    def default_spatial_inertia(self) -> SpatialInertia_[float]: ...
    def default_unit_inertia(self) -> UnitInertia_[float]: ...

class _TemporaryName_N5drake9multibody9RigidBodyINS_8symbolic10ExpressionEEE(Body_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_name: str, M_BBo_B: SpatialInertia_[float]) -> None: ...
    @overload
    def __init__(self, body_name: str, model_instance: ModelInstanceIndex, M_BBo_B: SpatialInertia_[float]) -> None: ...
    def SetCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[Expression], com: numpy.ndarray[object[3,1]]) -> None: ...
    def SetMass(self, context: pydrake.systems.framework.Context_[Expression], mass: pydrake.symbolic.Expression) -> None: ...
    def SetSpatialInertiaInBodyFrame(self, context: pydrake.systems.framework.Context_[Expression], M_Bo_B) -> None: ...
    def default_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def default_mass(self) -> float: ...
    def default_rotational_inertia(self) -> RotationalInertia_[float]: ...
    def default_spatial_inertia(self) -> SpatialInertia_[float]: ...
    def default_unit_inertia(self) -> UnitInertia_[float]: ...

class _TemporaryName_N5drake9multibody9RigidBodyIdEE(Body_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_name: str, M_BBo_B) -> None: ...
    @overload
    def __init__(self, body_name: str, model_instance: ModelInstanceIndex, M_BBo_B) -> None: ...
    def SetCenterOfMassInBodyFrame(self, context: pydrake.systems.framework.Context_[float], com: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def SetMass(self, context: pydrake.systems.framework.Context_[float], mass: float) -> None: ...
    def SetSpatialInertiaInBodyFrame(self, context: pydrake.systems.framework.Context_[float], M_Bo_B) -> None: ...
    def default_com(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def default_mass(self) -> float: ...
    def default_rotational_inertia(self, *args, **kwargs) -> Any: ...
    def default_spatial_inertia(self, *args, **kwargs) -> Any: ...
    def default_unit_inertia(self, *args, **kwargs) -> Any: ...

class _TemporaryName_N5drake9multibody9WeldJointIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Joint_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent_F: Frame_[AutoDiffXd], frame_on_child_M: Frame_[AutoDiffXd], X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def X_FM(self) -> pydrake.math.RigidTransform_[float]: ...

class _TemporaryName_N5drake9multibody9WeldJointINS_8symbolic10ExpressionEEE(Joint_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent_F: Frame_[Expression], frame_on_child_M: Frame_[Expression], X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def X_FM(self) -> pydrake.math.RigidTransform_[float]: ...

class _TemporaryName_N5drake9multibody9WeldJointIdEE(Joint_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, name: str, frame_on_parent_F: Frame_[float], frame_on_child_M: Frame_[float], X_FM: pydrake.math.RigidTransform_[float]) -> None: ...
    def X_FM(self) -> pydrake.math.RigidTransform_[float]: ...

def CalcSpatialInertia(const
geometry, double) -> Any: ...
def default_model_instance() -> ModelInstanceIndex: ...
def world_frame_index() -> FrameIndex: ...
def world_index() -> BodyIndex: ...
def world_model_instance() -> ModelInstanceIndex: ...
