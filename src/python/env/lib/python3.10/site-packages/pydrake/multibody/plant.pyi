from typing import Any, ClassVar, List, Optional, Tuple

from typing import overload
import flags
import numpy
import pydrake.autodiffutils
import pydrake.common.cpp_template
import pydrake.common.value
import pydrake.geometry
import pydrake.lcm
import pydrake.math
import pydrake.multibody.math
import pydrake.multibody.tree
import pydrake.symbolic
import pydrake.systems.framework
import pydrake.systems.lcm
ContactResults_: pydrake.common.cpp_template.TemplateClass
CoulombFriction_: pydrake.common.cpp_template.TemplateClass
ExternallyAppliedSpatialForceMultiplexer_: pydrake.common.cpp_template.TemplateClass
ExternallyAppliedSpatialForce_: pydrake.common.cpp_template.TemplateClass
HydroelasticContactInfo_: pydrake.common.cpp_template.TemplateClass
MultibodyPlant_: pydrake.common.cpp_template.TemplateClass
PointPairContactInfo_: pydrake.common.cpp_template.TemplateClass
Propeller_: pydrake.common.cpp_template.TemplateClass
Wing_: pydrake.common.cpp_template.TemplateClass

class ContactModel:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kHydroelastic: ClassVar[ContactModel] = ...
    kHydroelasticWithFallback: ClassVar[ContactModel] = ...
    kHydroelasticsOnly: ClassVar[ContactModel] = ...
    kPoint: ClassVar[ContactModel] = ...
    kPointContactOnly: ClassVar[ContactModel] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ContactResults:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_[float]: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_[float]: ...
    def __copy__(self) -> ContactResults_[float]: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_[float]: ...

class ContactResultsToLcmSystem(pydrake.systems.framework.LeafSystem_[float]):
    def __init__(self, plant) -> None: ...
    def get_contact_result_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_lcm_message_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...

class ContactResults_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_[AutoDiffXd]: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_[AutoDiffXd]: ...
    def __copy__(self) -> ContactResults_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_[AutoDiffXd]: ...

class ContactResults_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_[Expression]: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_[Expression]: ...
    def __copy__(self) -> ContactResults_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_[Expression]: ...

class ContactResults_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_[float]: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_[float]: ...
    def __copy__(self) -> ContactResults_[float]: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_[float]: ...

class CoulombFriction:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: float, dynamic_friction: float) -> None: ...
    def dynamic_friction(self) -> float: ...
    def static_friction(self) -> float: ...
    def __copy__(self) -> CoulombFriction_[float]: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_[float]: ...
    def __getstate__(self) -> Tuple[float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float]) -> None: ...

class CoulombFriction_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: pydrake.autodiffutils.AutoDiffXd, dynamic_friction: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def dynamic_friction(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def static_friction(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> CoulombFriction_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_[AutoDiffXd]: ...
    def __getstate__(self) -> Tuple[pydrake.autodiffutils.AutoDiffXd,pydrake.autodiffutils.AutoDiffXd]: ...
    def __setstate__(self, arg0: Tuple[pydrake.autodiffutils.AutoDiffXd,pydrake.autodiffutils.AutoDiffXd]) -> None: ...

class CoulombFriction_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: pydrake.symbolic.Expression, dynamic_friction: pydrake.symbolic.Expression) -> None: ...
    def dynamic_friction(self) -> pydrake.symbolic.Expression: ...
    def static_friction(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> CoulombFriction_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_[Expression]: ...
    def __getstate__(self) -> Tuple[pydrake.symbolic.Expression,pydrake.symbolic.Expression]: ...
    def __setstate__(self, arg0: Tuple[pydrake.symbolic.Expression,pydrake.symbolic.Expression]) -> None: ...

class CoulombFriction_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: float, dynamic_friction: float) -> None: ...
    def dynamic_friction(self) -> float: ...
    def static_friction(self) -> float: ...
    def __copy__(self) -> CoulombFriction_[float]: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_[float]: ...
    def __getstate__(self) -> Tuple[float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float]) -> None: ...

class DeformableBodyId:
    def __init__(self, *args, **kwargs) -> None: ...
    def get_new_id(self, *args, **kwargs) -> Any: ...
    def get_value(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, arg0: DeformableBodyId) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, arg0: DeformableBodyId) -> bool: ...
    def __ne__(self, arg0: DeformableBodyId) -> bool: ...

class DeformableModel(PhysicalModel):
    def __init__(self, arg0) -> None: ...
    def GetBodyId(self, *args, **kwargs) -> Any: ...
    def GetDiscreteStateIndex(self, id) -> pydrake.systems.framework.DiscreteStateIndex: ...
    def GetGeometryId(self, id) -> pydrake.geometry.GeometryId: ...
    def GetReferencePositions(self, id) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def RegisterDeformableBody(self, *args, **kwargs) -> Any: ...
    def num_bodies(self) -> int: ...
    def vertex_positions_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...

class DiscreteContactSolver:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kSap: ClassVar[DiscreteContactSolver] = ...
    kTamsi: ClassVar[DiscreteContactSolver] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ExternallyAppliedSpatialForce:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_[float]
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_[float]: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_[float]: ...

class ExternallyAppliedSpatialForceMultiplexer(pydrake.systems.framework.LeafSystem_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class ExternallyAppliedSpatialForceMultiplexer_[AutoDiffXd](pydrake.systems.framework.LeafSystem_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class ExternallyAppliedSpatialForceMultiplexer_[Expression](pydrake.systems.framework.LeafSystem_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class ExternallyAppliedSpatialForceMultiplexer_[float](pydrake.systems.framework.LeafSystem_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class ExternallyAppliedSpatialForce_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_[AutoDiffXd]
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[object[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_[AutoDiffXd]: ...

class ExternallyAppliedSpatialForce_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_[Expression]
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[object[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_[Expression]: ...

class ExternallyAppliedSpatialForce_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_[float]
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_[float]: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_[float]: ...

class HydroelasticContactInfo:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_[float]: ...
    def contact_surface(self) -> pydrake.geometry.ContactSurface_[float]: ...
    def __copy__(self) -> HydroelasticContactInfo_[float]: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_[float]: ...

class HydroelasticContactInfo_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_[AutoDiffXd]: ...
    def contact_surface(self) -> pydrake.geometry.ContactSurface_[AutoDiffXd]: ...
    def __copy__(self) -> HydroelasticContactInfo_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_[AutoDiffXd]: ...

class HydroelasticContactInfo_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_[Expression]: ...
    def contact_surface(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> HydroelasticContactInfo_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_[Expression]: ...

class HydroelasticContactInfo_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_[float]: ...
    def contact_surface(self) -> pydrake.geometry.ContactSurface_[float]: ...
    def __copy__(self) -> HydroelasticContactInfo_[float]: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_[float]: ...

class MultibodyPlant(pydrake.systems.framework.LeafSystem_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_[float], joint1: pydrake.multibody.tree.Joint_[float], gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.ConstraintIndex: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_[float]) -> pydrake.multibody.tree.ForceElement_[float]: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_[float]) -> pydrake.multibody.tree.Frame_[float]: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_[float]) -> pydrake.multibody.tree.Joint_[float]: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_[float], effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_[float]: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, model: PhysicalModel) -> None: ...
    @overload
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[float]: ...
    @overload
    def AddRigidBody(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[float]: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBp_B: numpy.ndarray[numpy.float64[3,1]], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,n]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[float], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_[float], forces: pydrake.multibody.tree.MultibodyForces_[float]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_[float], known_vdot: numpy.ndarray[numpy.float64[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[float], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_[float], frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BP: numpy.ndarray[numpy.float64[3,1]], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_[float], frame_B: pydrake.multibody.tree.Frame_[float], p_BQi: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_[float], frame_A: pydrake.multibody.tree.Frame_[float], frame_B: pydrake.multibody.tree.Frame_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_[float], known_vdot: numpy.ndarray[numpy.float64[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_[float]]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_[float], frame_F: pydrake.multibody.tree.Frame_[float], body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_[float]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[float], p_WoP_W: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[float]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context, p_WoScm_W) -> Any: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[float], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[float]: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[float], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> float: ...
    @overload
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_[float]]) -> pydrake.geometry.GeometrySet: ...
    @overload
    def CollectRegisteredGeometries(self, bodies) -> Any: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_[float]) -> list: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_[float]: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[float]: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_[float]: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_[float]) -> List[pydrake.geometry.GeometryId]: ...
    def GetDefaultContactSurfaceRepresentation(self, *args, **kwargs) -> Any: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_[float]: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_[float]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_[float]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[float]: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[float]: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_[float]: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_[float]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[float]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, conststd) -> Any: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_[float], qdot: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_[float], v: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_[float]) -> pydrake.geometry.SourceId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, coulomb_friction: CoulombFriction_[float]) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[numpy.float64[m,1]], u: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[float], X_WB: pydrake.math.RigidTransform_[float]) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_[float], state: pydrake.systems.framework.State_[float]) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float], X_WB: pydrake.math.RigidTransform_[float]) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_[float], V_WB: pydrake.multibody.math.SpatialVelocity_[float], context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[float], q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float], q_v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]], q: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[float], v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[numpy.float64[m,1]], v: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_[float], frame_on_child_M: pydrake.multibody.tree.Frame_[float], X_FM: pydrake.math.RigidTransform_[float] = ...) -> pydrake.multibody.tree.WeldJoint_[float]: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_[float]: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_[float]: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_[float]: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[float]: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_[float]: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[float]: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[float]: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[float]: ...
    def is_finalized(self) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[float]: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_actuators(self) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self) -> List[PhysicalModel]: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_[float]: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_[float]: ...

class MultibodyPlantConfig:
    __fields__: ClassVar[tuple] = ...  # read-only
    contact_model: str
    contact_surface_representation: str
    discrete_contact_solver: str
    penetration_allowance: float
    stiction_tolerance: float
    time_step: float
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> MultibodyPlantConfig: ...
    def __deepcopy__(self, arg0: dict) -> MultibodyPlantConfig: ...

class MultibodyPlant_[AutoDiffXd](pydrake.systems.framework.LeafSystem_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    @overload
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_[AutoDiffXd], joint1: pydrake.multibody.tree.Joint_[AutoDiffXd], gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.ConstraintIndex: ...
    @overload
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_[AutoDiffXd], joint1: pydrake.multibody.tree.Joint_[AutoDiffXd], gear_ratio: pydrake.autodiffutils.AutoDiffXd, offset: pydrake.autodiffutils.AutoDiffXd = ...) -> pydrake.multibody.tree.ConstraintIndex: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_[AutoDiffXd]) -> pydrake.multibody.tree.ForceElement_[AutoDiffXd]: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> pydrake.multibody.tree.Frame_[AutoDiffXd]: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_[AutoDiffXd]) -> pydrake.multibody.tree.Joint_[AutoDiffXd]: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_[AutoDiffXd], effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_[AutoDiffXd]: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, *args, **kwargs) -> Any: ...
    @overload
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[AutoDiffXd]: ...
    @overload
    def AddRigidBody(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[AutoDiffXd]: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> numpy.ndarray[object[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_[AutoDiffXd], forces: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_[AutoDiffXd], known_vdot: numpy.ndarray[object[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BP: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BQi: numpy.ndarray[object[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_[AutoDiffXd], known_vdot: numpy.ndarray[object[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_F: pydrake.multibody.tree.Frame_[AutoDiffXd], body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[AutoDiffXd], p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context, p_WoScm_W) -> Any: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_[AutoDiffXd]]) -> pydrake.geometry.GeometrySet: ...
    @overload
    def CollectRegisteredGeometries(self, bodies) -> Any: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd]) -> pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_[AutoDiffXd]) -> list: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_[AutoDiffXd]: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[AutoDiffXd]: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_[AutoDiffXd]: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_[AutoDiffXd]) -> List[pydrake.geometry.GeometryId]: ...
    def GetDefaultContactSurfaceRepresentation(self, *args, **kwargs) -> Any: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[AutoDiffXd]) -> pydrake.math.RigidTransform_[float]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_[AutoDiffXd]: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_[AutoDiffXd]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_[AutoDiffXd]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[AutoDiffXd]: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[AutoDiffXd]: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_[AutoDiffXd]: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_[AutoDiffXd]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[AutoDiffXd]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[object[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, conststd) -> Any: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], qdot: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_[AutoDiffXd], v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_[AutoDiffXd]) -> pydrake.geometry.SourceId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[AutoDiffXd], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[AutoDiffXd], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, coulomb_friction: CoulombFriction_[float]) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_[AutoDiffXd], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[AutoDiffXd], X_WB: pydrake.math.RigidTransform_[float]) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_[AutoDiffXd], state: pydrake.systems.framework.State_[AutoDiffXd]) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd], X_WB: pydrake.math.RigidTransform_[AutoDiffXd]) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_[AutoDiffXd], V_WB: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd], q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], q_v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m,1]], q: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m,1]], v: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child_M: pydrake.multibody.tree.Frame_[AutoDiffXd], X_FM: pydrake.math.RigidTransform_[float] = ...) -> pydrake.multibody.tree.WeldJoint_[AutoDiffXd]: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_[AutoDiffXd]: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_[AutoDiffXd]: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_[AutoDiffXd]: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[AutoDiffXd]: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_[AutoDiffXd]: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[AutoDiffXd]: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]: ...
    def is_finalized(self) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_actuators(self) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self, *args, **kwargs) -> Any: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_[AutoDiffXd]: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_[AutoDiffXd]: ...

class MultibodyPlant_[Expression](pydrake.systems.framework.LeafSystem_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    @overload
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_[Expression], joint1: pydrake.multibody.tree.Joint_[Expression], gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.ConstraintIndex: ...
    @overload
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_[Expression], joint1: pydrake.multibody.tree.Joint_[Expression], gear_ratio: pydrake.symbolic.Expression, offset: pydrake.symbolic.Expression = ...) -> pydrake.multibody.tree.ConstraintIndex: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_[Expression]) -> pydrake.multibody.tree.ForceElement_[Expression]: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_[Expression]) -> pydrake.multibody.tree.Frame_[Expression]: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_[Expression]) -> pydrake.multibody.tree.Joint_[Expression]: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_[Expression], effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_[Expression]: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, model) -> None: ...
    @overload
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[Expression]: ...
    @overload
    def AddRigidBody(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[Expression]: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> pydrake.multibody.math.SpatialAcceleration_[Expression]: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[Expression], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> numpy.ndarray[object[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_[Expression], forces: pydrake.multibody.tree.MultibodyForces_[Expression]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_[Expression], known_vdot: numpy.ndarray[object[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[Expression], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_[Expression], frame_B: pydrake.multibody.tree.Frame_[Expression], p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], p_BP: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_[Expression], frame_B: pydrake.multibody.tree.Frame_[Expression], p_BQi: numpy.ndarray[object[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_[Expression], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_B: pydrake.multibody.tree.Frame_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_[Expression], known_vdot: numpy.ndarray[object[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_[Expression]]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_[Expression], frame_F: pydrake.multibody.tree.Frame_[Expression], body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_[Expression]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[Expression], p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[Expression]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context, p_WoScm_W) -> Any: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[Expression], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[Expression]: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[Expression], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> pydrake.symbolic.Expression: ...
    @overload
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_[Expression]]) -> pydrake.geometry.GeometrySet: ...
    @overload
    def CollectRegisteredGeometries(self, bodies) -> Any: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.Body_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.Body_[Expression]) -> pydrake.multibody.math.SpatialVelocity_[Expression]: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_[Expression]) -> list: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_[Expression]: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[Expression]: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_[Expression]: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_[Expression]) -> List[pydrake.geometry.GeometryId]: ...
    def GetDefaultContactSurfaceRepresentation(self, *args, **kwargs) -> Any: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[Expression]) -> pydrake.math.RigidTransform_[float]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_[Expression]: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_[Expression]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.Body_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_[Expression]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[Expression]: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[Expression]: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_[Expression]: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_[Expression]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[Expression]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[object[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, conststd) -> Any: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_[Expression], qdot: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_[Expression], v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_[Expression]) -> pydrake.geometry.SourceId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[Expression], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[Expression], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, coulomb_friction: CoulombFriction_[float]) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_[Expression], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[Expression], X_WB: pydrake.math.RigidTransform_[float]) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_[Expression], state: pydrake.systems.framework.State_[Expression]) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.Body_[Expression], X_WB: pydrake.math.RigidTransform_[Expression]) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_[Expression], V_WB: pydrake.multibody.math.SpatialVelocity_[Expression], context: pydrake.systems.framework.Context_[Expression]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[Expression], q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[Expression], q_v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m,1]], q: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[Expression], v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m,1]], v: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_[Expression], frame_on_child_M: pydrake.multibody.tree.Frame_[Expression], X_FM: pydrake.math.RigidTransform_[float] = ...) -> pydrake.multibody.tree.WeldJoint_[Expression]: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_[Expression]: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_[Expression]: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_[Expression]: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[Expression]: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_[Expression]: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[Expression]: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[Expression]: ...
    def is_finalized(self) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[Expression]: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_actuators(self) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self, *args, **kwargs) -> Any: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_[Expression]: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_[Expression]: ...

class MultibodyPlant_[float](pydrake.systems.framework.LeafSystem_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_[float], joint1: pydrake.multibody.tree.Joint_[float], gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.ConstraintIndex: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_[float]) -> pydrake.multibody.tree.ForceElement_[float]: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_[float]) -> pydrake.multibody.tree.Frame_[float]: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_[float]) -> pydrake.multibody.tree.Joint_[float]: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_[float], effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_[float]: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, model: PhysicalModel) -> None: ...
    @overload
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[float]: ...
    @overload
    def AddRigidBody(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[float]: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBp_B: numpy.ndarray[numpy.float64[3,1]], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,n]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[float], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_[float], forces: pydrake.multibody.tree.MultibodyForces_[float]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_[float], known_vdot: numpy.ndarray[numpy.float64[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[float], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_[float], frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BP: numpy.ndarray[numpy.float64[3,1]], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_[float], frame_B: pydrake.multibody.tree.Frame_[float], p_BQi: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_[float], frame_A: pydrake.multibody.tree.Frame_[float], frame_B: pydrake.multibody.tree.Frame_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_[float], known_vdot: numpy.ndarray[numpy.float64[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_[float]]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_[float], frame_F: pydrake.multibody.tree.Frame_[float], body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_[float]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[float], p_WoP_W: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[float]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context, p_WoScm_W) -> Any: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[float], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[float]: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[float], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> float: ...
    @overload
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_[float]]) -> pydrake.geometry.GeometrySet: ...
    @overload
    def CollectRegisteredGeometries(self, bodies) -> Any: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_[float]) -> list: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_[float]: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[float]: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_[float]: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_[float]) -> List[pydrake.geometry.GeometryId]: ...
    def GetDefaultContactSurfaceRepresentation(self, *args, **kwargs) -> Any: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_[float]: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_[float]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_[float]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[float]: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[float]: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_[float]: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_[float]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[float]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, conststd) -> Any: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_[float], qdot: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_[float], v: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_[float]) -> pydrake.geometry.SourceId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, coulomb_friction: CoulombFriction_[float]) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[numpy.float64[m,1]], u: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[float], X_WB: pydrake.math.RigidTransform_[float]) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_[float], state: pydrake.systems.framework.State_[float]) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float], X_WB: pydrake.math.RigidTransform_[float]) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_[float], V_WB: pydrake.multibody.math.SpatialVelocity_[float], context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[float], q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float], q_v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]], q: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[float], v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[numpy.float64[m,1]], v: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_[float], frame_on_child_M: pydrake.multibody.tree.Frame_[float], X_FM: pydrake.math.RigidTransform_[float] = ...) -> pydrake.multibody.tree.WeldJoint_[float]: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_[float]: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_[float]: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_[float]: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[float]: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_[float]: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[float]: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[float]: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[float]: ...
    def is_finalized(self) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[float]: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_actuators(self) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self) -> List[PhysicalModel]: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_[float]: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_[float]: ...

class PhysicalModel:
    def __init__(self, *args, **kwargs) -> None: ...

class PointPairContactInfo:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[numpy.float64[3,1]], p_WC: numpy.ndarray[numpy.float64[3,1]], separation_speed: float, slip_speed: float, point_pair: pydrake.geometry.PenetrationAsPointPair_[float]) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_[float]: ...
    def separation_speed(self) -> float: ...
    def slip_speed(self) -> float: ...
    def __copy__(self) -> PointPairContactInfo_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_[float]: ...

class PointPairContactInfo_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3,1]], p_WC: numpy.ndarray[object[3,1]], separation_speed: pydrake.autodiffutils.AutoDiffXd, slip_speed: pydrake.autodiffutils.AutoDiffXd, point_pair: pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd]) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[object[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[object[3,1]]: ...
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd]: ...
    def separation_speed(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def slip_speed(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> PointPairContactInfo_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_[AutoDiffXd]: ...

class PointPairContactInfo_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3,1]], p_WC: numpy.ndarray[object[3,1]], separation_speed: pydrake.symbolic.Expression, slip_speed: pydrake.symbolic.Expression, point_pair: pydrake.geometry.PenetrationAsPointPair_[Expression]) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[object[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[object[3,1]]: ...
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_[Expression]: ...
    def separation_speed(self) -> pydrake.symbolic.Expression: ...
    def slip_speed(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> PointPairContactInfo_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_[Expression]: ...

class PointPairContactInfo_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[numpy.float64[3,1]], p_WC: numpy.ndarray[numpy.float64[3,1]], separation_speed: float, slip_speed: float, point_pair: pydrake.geometry.PenetrationAsPointPair_[float]) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_[float]: ...
    def separation_speed(self) -> float: ...
    def slip_speed(self) -> float: ...
    def __copy__(self) -> PointPairContactInfo_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_[float]: ...

class Propeller(pydrake.systems.framework.LeafSystem_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform_[float] = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def num_propellers(self) -> int: ...

class PropellerInfo:
    X_BP: pydrake.math.RigidTransform_[float]
    body_index: pydrake.multibody.tree.BodyIndex
    moment_ratio: float
    thrust_ratio: float
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform_[float] = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    def __copy__(self) -> PropellerInfo: ...
    def __deepcopy__(self, arg0: dict) -> PropellerInfo: ...

class Propeller_[AutoDiffXd](pydrake.systems.framework.LeafSystem_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform_[float] = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def num_propellers(self) -> int: ...

class Propeller_[Expression](pydrake.systems.framework.LeafSystem_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform_[float] = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def num_propellers(self) -> int: ...

class Propeller_[float](pydrake.systems.framework.LeafSystem_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform_[float] = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def num_propellers(self) -> int: ...

class Wing(pydrake.systems.framework.LeafSystem_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform_[float] = ..., fluid_density: float = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...

class Wing_[AutoDiffXd](pydrake.systems.framework.LeafSystem_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform_[float] = ..., fluid_density: float = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...

class Wing_[Expression](pydrake.systems.framework.LeafSystem_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform_[float] = ..., fluid_density: float = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...

class Wing_[float](pydrake.systems.framework.LeafSystem_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform_[float] = ..., fluid_density: float = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...

class _TemporaryName_N5drake5ValueINS_9multibody14ContactResultsIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ContactResults_[AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ContactResults_[AutoDiffXd]: ...
    def get_value(self) -> ContactResults_[AutoDiffXd]: ...
    def set_value(self, arg0: ContactResults_[AutoDiffXd]) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody14ContactResultsINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ContactResults_[Expression]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ContactResults_[Expression]: ...
    def get_value(self) -> ContactResults_[Expression]: ...
    def set_value(self, arg0: ContactResults_[Expression]) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody14ContactResultsIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ContactResults_[float]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ContactResults_[float]: ...
    def get_value(self) -> ContactResults_[float]: ...
    def set_value(self, arg0: ContactResults_[float]) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody15CoulombFrictionIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: CoulombFriction_[AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> CoulombFriction_[AutoDiffXd]: ...
    def get_value(self) -> CoulombFriction_[AutoDiffXd]: ...
    def set_value(self, arg0: CoulombFriction_[AutoDiffXd]) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody15CoulombFrictionINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: CoulombFriction_[Expression]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> CoulombFriction_[Expression]: ...
    def get_value(self) -> CoulombFriction_[Expression]: ...
    def set_value(self, arg0: CoulombFriction_[Expression]) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody15CoulombFrictionIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: CoulombFriction_[float]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> CoulombFriction_[float]: ...
    def get_value(self) -> CoulombFriction_[float]: ...
    def set_value(self, arg0: CoulombFriction_[float]) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody23HydroelasticContactInfoIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: HydroelasticContactInfo_[AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> HydroelasticContactInfo_[AutoDiffXd]: ...
    def get_value(self) -> HydroelasticContactInfo_[AutoDiffXd]: ...
    def set_value(self, arg0: HydroelasticContactInfo_[AutoDiffXd]) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody23HydroelasticContactInfoINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: HydroelasticContactInfo_[Expression]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> HydroelasticContactInfo_[Expression]: ...
    def get_value(self) -> HydroelasticContactInfo_[Expression]: ...
    def set_value(self, arg0: HydroelasticContactInfo_[Expression]) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody23HydroelasticContactInfoIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: HydroelasticContactInfo_[float]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> HydroelasticContactInfo_[float]: ...
    def get_value(self) -> HydroelasticContactInfo_[float]: ...
    def set_value(self, arg0: HydroelasticContactInfo_[float]) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody29ExternallyAppliedSpatialForceIN5Eigen14AutoDiffScalarINS3_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ExternallyAppliedSpatialForce_[AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ExternallyAppliedSpatialForce_[AutoDiffXd]: ...
    def get_value(self) -> ExternallyAppliedSpatialForce_[AutoDiffXd]: ...
    def set_value(self, arg0: ExternallyAppliedSpatialForce_[AutoDiffXd]) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody29ExternallyAppliedSpatialForceINS_8symbolic10ExpressionEEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ExternallyAppliedSpatialForce_[Expression]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ExternallyAppliedSpatialForce_[Expression]: ...
    def get_value(self) -> ExternallyAppliedSpatialForce_[Expression]: ...
    def set_value(self, arg0: ExternallyAppliedSpatialForce_[Expression]) -> None: ...

class _TemporaryName_N5drake5ValueINS_9multibody29ExternallyAppliedSpatialForceIdEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: ExternallyAppliedSpatialForce_[float]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> ExternallyAppliedSpatialForce_[float]: ...
    def get_value(self) -> ExternallyAppliedSpatialForce_[float]: ...
    def set_value(self, arg0: ExternallyAppliedSpatialForce_[float]) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_9multibody29ExternallyAppliedSpatialForceIN5Eigen14AutoDiffScalarINS4_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEESaIS9_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[ExternallyAppliedSpatialForce_[AutoDiffXd]]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[ExternallyAppliedSpatialForce_[AutoDiffXd]]: ...
    def set_value(self, arg0: List[ExternallyAppliedSpatialForce_[AutoDiffXd]]) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_9multibody29ExternallyAppliedSpatialForceINS_8symbolic10ExpressionEEESaIS6_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[ExternallyAppliedSpatialForce_[Expression]]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[ExternallyAppliedSpatialForce_[Expression]]: ...
    def set_value(self, arg0: List[ExternallyAppliedSpatialForce_[Expression]]) -> None: ...

class _TemporaryName_N5drake5ValueISt6vectorINS_9multibody29ExternallyAppliedSpatialForceIdEESaIS4_EEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: List[ExternallyAppliedSpatialForce_[float]]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> None: ...
    def get_value(self) -> List[ExternallyAppliedSpatialForce_[float]]: ...
    def set_value(self, arg0: List[ExternallyAppliedSpatialForce_[float]]) -> None: ...

class _TemporaryName_N5drake9multibody14ContactResultsIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_[AutoDiffXd]: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_[AutoDiffXd]: ...
    def __copy__(self) -> ContactResults_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_[AutoDiffXd]: ...

class _TemporaryName_N5drake9multibody14ContactResultsINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_[Expression]: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_[Expression]: ...
    def __copy__(self) -> ContactResults_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_[Expression]: ...

class _TemporaryName_N5drake9multibody14ContactResultsIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def hydroelastic_contact_info(self, i: int) -> HydroelasticContactInfo_[float]: ...
    def num_hydroelastic_contacts(self) -> int: ...
    def num_point_pair_contacts(self) -> int: ...
    def plant(self, *args, **kwargs) -> Any: ...
    def point_pair_contact_info(self, i: int) -> PointPairContactInfo_[float]: ...
    def __copy__(self) -> ContactResults_[float]: ...
    def __deepcopy__(self, arg0: dict) -> ContactResults_[float]: ...

class _TemporaryName_N5drake9multibody14MultibodyPlantIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    @overload
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_[AutoDiffXd], joint1: pydrake.multibody.tree.Joint_[AutoDiffXd], gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.ConstraintIndex: ...
    @overload
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_[AutoDiffXd], joint1: pydrake.multibody.tree.Joint_[AutoDiffXd], gear_ratio: pydrake.autodiffutils.AutoDiffXd, offset: pydrake.autodiffutils.AutoDiffXd = ...) -> pydrake.multibody.tree.ConstraintIndex: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_[AutoDiffXd]) -> pydrake.multibody.tree.ForceElement_[AutoDiffXd]: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> pydrake.multibody.tree.Frame_[AutoDiffXd]: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_[AutoDiffXd]) -> pydrake.multibody.tree.Joint_[AutoDiffXd]: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_[AutoDiffXd], effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_[AutoDiffXd]: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, *args, **kwargs) -> Any: ...
    @overload
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[AutoDiffXd]: ...
    @overload
    def AddRigidBody(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[AutoDiffXd]: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> numpy.ndarray[object[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_[AutoDiffXd], forces: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_[AutoDiffXd], known_vdot: numpy.ndarray[object[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BP: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BQi: numpy.ndarray[object[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_[AutoDiffXd], known_vdot: numpy.ndarray[object[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_[AutoDiffXd], frame_F: pydrake.multibody.tree.Frame_[AutoDiffXd], body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[AutoDiffXd], p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context, p_WoScm_W) -> Any: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_[AutoDiffXd]]) -> pydrake.geometry.GeometrySet: ...
    @overload
    def CollectRegisteredGeometries(self, bodies) -> Any: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd]) -> pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_[AutoDiffXd]) -> list: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_[AutoDiffXd]: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[AutoDiffXd]: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_[AutoDiffXd]: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_[AutoDiffXd]) -> List[pydrake.geometry.GeometryId]: ...
    def GetDefaultContactSurfaceRepresentation(self, *args, **kwargs) -> Any: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[AutoDiffXd]) -> pydrake.math.RigidTransform_[float]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_[AutoDiffXd]: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_[AutoDiffXd]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd]) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_[AutoDiffXd]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[AutoDiffXd]: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[AutoDiffXd]: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_[AutoDiffXd]: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_[AutoDiffXd]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[AutoDiffXd]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[object[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, conststd) -> Any: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_[AutoDiffXd], qdot: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_[AutoDiffXd], v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_[AutoDiffXd]) -> pydrake.geometry.SourceId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[AutoDiffXd], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[AutoDiffXd], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, coulomb_friction: CoulombFriction_[float]) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_[AutoDiffXd], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[AutoDiffXd], X_WB: pydrake.math.RigidTransform_[float]) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_[AutoDiffXd], state: pydrake.systems.framework.State_[AutoDiffXd]) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd], X_WB: pydrake.math.RigidTransform_[AutoDiffXd]) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_[AutoDiffXd], V_WB: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd], q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], q_v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m,1]], q: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m,1]], v: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child_M: pydrake.multibody.tree.Frame_[AutoDiffXd], X_FM: pydrake.math.RigidTransform_[float] = ...) -> pydrake.multibody.tree.WeldJoint_[AutoDiffXd]: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_[AutoDiffXd]: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_[AutoDiffXd]: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_[AutoDiffXd]: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[AutoDiffXd]: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_[AutoDiffXd]: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[AutoDiffXd]: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]: ...
    def is_finalized(self) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_actuators(self) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self, *args, **kwargs) -> Any: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_[AutoDiffXd]: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_[AutoDiffXd]: ...

class _TemporaryName_N5drake9multibody14MultibodyPlantINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    @overload
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_[Expression], joint1: pydrake.multibody.tree.Joint_[Expression], gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.ConstraintIndex: ...
    @overload
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_[Expression], joint1: pydrake.multibody.tree.Joint_[Expression], gear_ratio: pydrake.symbolic.Expression, offset: pydrake.symbolic.Expression = ...) -> pydrake.multibody.tree.ConstraintIndex: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_[Expression]) -> pydrake.multibody.tree.ForceElement_[Expression]: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_[Expression]) -> pydrake.multibody.tree.Frame_[Expression]: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_[Expression]) -> pydrake.multibody.tree.Joint_[Expression]: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_[Expression], effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_[Expression]: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, model) -> None: ...
    @overload
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[Expression]: ...
    @overload
    def AddRigidBody(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[Expression]: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], p_BoBp_B: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> pydrake.multibody.math.SpatialAcceleration_[Expression]: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[3,1]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[Expression], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> numpy.ndarray[object[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_[Expression], forces: pydrake.multibody.tree.MultibodyForces_[Expression]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_[Expression], known_vdot: numpy.ndarray[object[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[Expression], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_[Expression], frame_B: pydrake.multibody.tree.Frame_[Expression], p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], p_BP: numpy.ndarray[object[3,1]], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], p_BoBi_B: numpy.ndarray[object[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_[Expression], frame_B: pydrake.multibody.tree.Frame_[Expression], p_BQi: numpy.ndarray[object[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[Expression]) -> numpy.ndarray[object[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_[Expression], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_B: pydrake.multibody.tree.Frame_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_[Expression], known_vdot: numpy.ndarray[object[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_[Expression]]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_[Expression], frame_F: pydrake.multibody.tree.Frame_[Expression], body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_[Expression]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[Expression], p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[Expression]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context, p_WoScm_W) -> Any: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[Expression], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[object[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[Expression]: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[Expression]) -> pydrake.symbolic.Expression: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[Expression], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> pydrake.symbolic.Expression: ...
    @overload
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_[Expression]]) -> pydrake.geometry.GeometrySet: ...
    @overload
    def CollectRegisteredGeometries(self, bodies) -> Any: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.Body_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.Body_[Expression]) -> pydrake.multibody.math.SpatialVelocity_[Expression]: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_[Expression]) -> list: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_[Expression]: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[Expression]: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_[Expression]: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_[Expression]) -> List[pydrake.geometry.GeometryId]: ...
    def GetDefaultContactSurfaceRepresentation(self, *args, **kwargs) -> Any: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[Expression]) -> pydrake.math.RigidTransform_[float]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_[Expression]: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_[Expression]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.Body_[Expression]) -> pydrake.math.RigidTransform_[Expression]: ...
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_[Expression]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[Expression]: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[Expression]: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_[Expression]: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_[Expression]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[Expression]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[Expression]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[object[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, conststd) -> Any: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_[Expression], qdot: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_[Expression], v: numpy.ndarray[object[m,1]]) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_[Expression]) -> pydrake.geometry.SourceId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[Expression], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[Expression], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, coulomb_friction: CoulombFriction_[float]) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_[Expression], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m,1]], u: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[Expression], X_WB: pydrake.math.RigidTransform_[float]) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_[Expression], state: pydrake.systems.framework.State_[Expression]) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.Body_[Expression], X_WB: pydrake.math.RigidTransform_[Expression]) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_[Expression], V_WB: pydrake.multibody.math.SpatialVelocity_[Expression], context: pydrake.systems.framework.Context_[Expression]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[Expression], q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[Expression], q_v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m,1]], q: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[Expression], v: numpy.ndarray[object[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m,1]], v: Optional[numpy.ndarray[object[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_[Expression], frame_on_child_M: pydrake.multibody.tree.Frame_[Expression], X_FM: pydrake.math.RigidTransform_[float] = ...) -> pydrake.multibody.tree.WeldJoint_[Expression]: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_[Expression]: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_[Expression]: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_[Expression]: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[Expression]: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_[Expression]: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[Expression]: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[Expression]: ...
    def is_finalized(self) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[Expression]: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_actuators(self) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self, *args, **kwargs) -> Any: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_[Expression]: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_[Expression]: ...

class _TemporaryName_N5drake9multibody14MultibodyPlantIdEE(pydrake.systems.framework.LeafSystem_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, time_step: float) -> None: ...
    def AddCouplerConstraint(self, joint0: pydrake.multibody.tree.Joint_[float], joint1: pydrake.multibody.tree.Joint_[float], gear_ratio: float, offset: float = ...) -> pydrake.multibody.tree.ConstraintIndex: ...
    def AddForceElement(self, force_element: pydrake.multibody.tree.ForceElement_[float]) -> pydrake.multibody.tree.ForceElement_[float]: ...
    def AddFrame(self, frame: pydrake.multibody.tree.Frame_[float]) -> pydrake.multibody.tree.Frame_[float]: ...
    def AddJoint(self, joint: pydrake.multibody.tree.Joint_[float]) -> pydrake.multibody.tree.Joint_[float]: ...
    def AddJointActuator(self, name: str, joint: pydrake.multibody.tree.Joint_[float], effort_limit: float = ...) -> pydrake.multibody.tree.JointActuator_[float]: ...
    def AddModelInstance(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def AddPhysicalModel(self, model: PhysicalModel) -> None: ...
    @overload
    def AddRigidBody(self, name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[float]: ...
    @overload
    def AddRigidBody(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -> pydrake.multibody.tree.RigidBody_[float]: ...
    def CalcBiasCenterOfMassTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcBiasSpatialAcceleration(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBp_B: numpy.ndarray[numpy.float64[3,1]], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> pydrake.multibody.math.SpatialAcceleration_[float]: ...
    def CalcBiasTerm(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcBiasTranslationalAcceleration(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,n]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    @overload
    def CalcCenterOfMassPositionInWorld(self, context: pydrake.systems.framework.Context_[float], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def CalcForceElementsContribution(self, context: pydrake.systems.framework.Context_[float], forces: pydrake.multibody.tree.MultibodyForces_[float]) -> None: ...
    def CalcGravityGeneralizedForces(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcInverseDynamics(self, context: pydrake.systems.framework.Context_[float], known_vdot: numpy.ndarray[numpy.float64[m,1]], external_forces: pydrake.multibody.tree.MultibodyForces_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def CalcJacobianAngularVelocity(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,n]]: ...
    @overload
    def CalcJacobianCenterOfMassTranslationalVelocity(self, context: pydrake.systems.framework.Context_[float], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[3,n]]: ...
    def CalcJacobianPositionVector(self, context: pydrake.systems.framework.Context_[float], frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcJacobianSpatialVelocity(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BP: numpy.ndarray[numpy.float64[3,1]], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcJacobianTranslationalVelocity(self, context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcMassMatrix(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcMassMatrixViaInverseDynamics(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcPointsPositions(self, context: pydrake.systems.framework.Context_[float], frame_B: pydrake.multibody.tree.Frame_[float], p_BQi: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def CalcRelativeTransform(self, context: pydrake.systems.framework.Context_[float], frame_A: pydrake.multibody.tree.Frame_[float], frame_B: pydrake.multibody.tree.Frame_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def CalcSpatialAccelerationsFromVdot(self, context: pydrake.systems.framework.Context_[float], known_vdot: numpy.ndarray[numpy.float64[m,1]]) -> List[pydrake.multibody.math.SpatialAcceleration_[float]]: ...
    def CalcSpatialInertia(self, context: pydrake.systems.framework.Context_[float], frame_F: pydrake.multibody.tree.Frame_[float], body_indexes: List[pydrake.multibody.tree.BodyIndex]) -> pydrake.multibody.tree.SpatialInertia_[float]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[float], p_WoP_W: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[float]: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context, p_WoScm_W) -> Any: ...
    @overload
    def CalcSpatialMomentumInWorldAboutPoint(self, context: pydrake.systems.framework.Context_[float], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex], p_WoP_W: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.multibody.math.SpatialMomentum_[float]: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[float]) -> float: ...
    @overload
    def CalcTotalMass(self, context: pydrake.systems.framework.Context_[float], model_instances: List[pydrake.multibody.tree.ModelInstanceIndex]) -> float: ...
    @overload
    def CollectRegisteredGeometries(self, bodies: List[pydrake.multibody.tree.Body_[float]]) -> pydrake.geometry.GeometrySet: ...
    @overload
    def CollectRegisteredGeometries(self, bodies) -> Any: ...
    def EvalBodyPoseInWorld(self, context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def EvalBodySpatialVelocityInWorld(self, context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]) -> pydrake.multibody.math.SpatialVelocity_[float]: ...
    @overload
    def Finalize(self) -> None: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    @overload
    def Finalize(self) -> Any: ...
    def GetAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetBodiesKinematicallyAffectedBy(self, joint_indexes: List[pydrake.multibody.tree.JointIndex]) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetBodiesWeldedTo(self, body: pydrake.multibody.tree.Body_[float]) -> list: ...
    @overload
    def GetBodyByName(self, name: str) -> pydrake.multibody.tree.Body_[float]: ...
    @overload
    def GetBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[float]: ...
    def GetBodyFrameIdIfExists(self, body_index: pydrake.multibody.tree.BodyIndex) -> Optional[pydrake.geometry.FrameId]: ...
    def GetBodyFrameIdOrThrow(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.geometry.FrameId: ...
    def GetBodyFromFrameId(self, arg0: pydrake.geometry.FrameId) -> pydrake.multibody.tree.Body_[float]: ...
    def GetBodyIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.BodyIndex]: ...
    def GetCollisionGeometriesForBody(self, body: pydrake.multibody.tree.Body_[float]) -> List[pydrake.geometry.GeometryId]: ...
    def GetDefaultContactSurfaceRepresentation(self, *args, **kwargs) -> Any: ...
    def GetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def GetEffortLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetEffortUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetFloatingBaseBodies(self) -> Set[pydrake.multibody.tree.BodyIndex]: ...
    @overload
    def GetFrameByName(self, name: str) -> pydrake.multibody.tree.Frame_[float]: ...
    @overload
    def GetFrameByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Frame_[float]: ...
    def GetFreeBodyPose(self, context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def GetJointActuatorByName(self, name: str) -> pydrake.multibody.tree.JointActuator_[float]: ...
    def GetJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[float]: ...
    def GetJointIndices(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> List[pydrake.multibody.tree.JointIndex]: ...
    def GetModelInstanceByName(self, name: str) -> pydrake.multibody.tree.ModelInstanceIndex: ...
    def GetModelInstanceName(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> str: ...
    def GetMutableJointByName(self, name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = ...) -> pydrake.multibody.tree.Joint_[float]: ...
    def GetMutablePositions(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetMutablePositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetMutableVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1],flags.writeable]: ...
    def GetPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositions(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetPositionsFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetRigidBodyByName(self, name: str) -> pydrake.multibody.tree.RigidBody_[float]: ...
    @overload
    def GetRigidBodyByName(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.RigidBody_[float]: ...
    def GetTopologyGraphvizString(self) -> str: ...
    def GetUniqueFreeBaseBodyOrThrow(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.multibody.tree.Body_[float]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[float]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def GetVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocitiesFromArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def HasBodyNamed(self, name: str) -> bool: ...
    @overload
    def HasBodyNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str) -> bool: ...
    @overload
    def HasJointActuatorNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    @overload
    def HasJointNamed(self, name: str) -> bool: ...
    @overload
    def HasJointNamed(self, name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def HasModelInstanceNamed(self, name: str) -> bool: ...
    def HasUniqueFreeBaseBody(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> bool: ...
    def MakeActuationMatrix(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_actuator_index_map: List[pydrake.multibody.tree.JointActuatorIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, user_to_joint_index_map: List[pydrake.multibody.tree.JointIndex]) -> numpy.ndarray[numpy.float64[m,n]]: ...
    @overload
    def MakeActuatorSelectorMatrix(self, conststd) -> Any: ...
    @overload
    def MapQDotToVelocity(self, context: pydrake.systems.framework.Context_[float], qdot: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def MapQDotToVelocity(self) -> Any: ...
    @overload
    def MapVelocityToQDot(self, context: pydrake.systems.framework.Context_[float], v: numpy.ndarray[numpy.float64[m,1]]) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @overload
    def MapVelocityToQDot(self) -> Any: ...
    def RegisterAsSourceForSceneGraph(self, scene_graph: pydrake.geometry.SceneGraph_[float]) -> pydrake.geometry.SourceId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -> pydrake.geometry.GeometryId: ...
    @overload
    def RegisterCollisionGeometry(self, body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, coulomb_friction: CoulombFriction_[float]) -> pydrake.geometry.GeometryId: ...
    def RegisterVisualGeometry(self, body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4,1]]) -> pydrake.geometry.GeometryId: ...
    def SetActuationInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[numpy.float64[m,1]], u: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    def SetDefaultFreeBodyPose(self, body: pydrake.multibody.tree.Body_[float], X_WB: pydrake.math.RigidTransform_[float]) -> None: ...
    @overload
    def SetDefaultPositions(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetDefaultPositions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetDefaultState(self, context: pydrake.systems.framework.Context_[float], state: pydrake.systems.framework.State_[float]) -> None: ...
    def SetFreeBodyPose(self, context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float], X_WB: pydrake.math.RigidTransform_[float]) -> None: ...
    def SetFreeBodySpatialVelocity(self, body: pydrake.multibody.tree.Body_[float], V_WB: pydrake.multibody.math.SpatialVelocity_[float], context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[float], q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositions(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float], q_v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetPositionsAndVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetPositionsInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m,1]], q: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[float], v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def SetVelocities(self, context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def SetVelocitiesInArray(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[numpy.float64[m,1]], v: Optional[numpy.ndarray[numpy.float64[m,1],flags.writeable]]) -> None: ...
    def WeldFrames(self, frame_on_parent_F: pydrake.multibody.tree.Frame_[float], frame_on_child_M: pydrake.multibody.tree.Frame_[float], X_FM: pydrake.math.RigidTransform_[float] = ...) -> pydrake.multibody.tree.WeldJoint_[float]: ...
    def geometry_source_is_registered(self) -> bool: ...
    @overload
    def get_actuation_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    @overload
    def get_actuation_input_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_applied_generalized_force_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_applied_spatial_force_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_body(self, body_index: pydrake.multibody.tree.BodyIndex) -> pydrake.multibody.tree.Body_[float]: ...
    def get_body_poses_output_port(self, *args, **kwargs) -> Any: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    @overload
    def get_body_spatial_accelerations_output_port(self) -> Any: ...
    def get_body_spatial_velocities_output_port(self, *args, **kwargs) -> Any: ...
    def get_contact_model(self) -> ContactModel: ...
    def get_contact_penalty_method_time_scale(self) -> float: ...
    def get_contact_results_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_contact_surface_representation(self) -> pydrake.geometry.HydroelasticContactRepresentation: ...
    def get_discrete_contact_solver(self) -> DiscreteContactSolver: ...
    def get_force_element(self, force_element_index: pydrake.multibody.tree.ForceElementIndex) -> pydrake.multibody.tree.ForceElement_[float]: ...
    def get_frame(self, frame_index: pydrake.multibody.tree.FrameIndex) -> pydrake.multibody.tree.Frame_[float]: ...
    @overload
    def get_generalized_acceleration_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    @overload
    def get_generalized_acceleration_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_generalized_contact_forces_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_geometry_poses_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_geometry_query_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[float]: ...
    def get_joint_actuator(self, actuator_index: pydrake.multibody.tree.JointActuatorIndex) -> pydrake.multibody.tree.JointActuator_[float]: ...
    def get_mutable_joint(self, joint_index: pydrake.multibody.tree.JointIndex) -> pydrake.multibody.tree.Joint_[float]: ...
    def get_reaction_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_source_id(self) -> Optional[pydrake.geometry.SourceId]: ...
    @overload
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    @overload
    def get_state_output_port(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> pydrake.systems.framework.OutputPort_[float]: ...
    def gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[float]: ...
    def is_finalized(self) -> bool: ...
    def mutable_gravity_field(self) -> pydrake.multibody.tree.UniformGravityFieldElement_[float]: ...
    @overload
    def num_actuated_dofs(self) -> int: ...
    @overload
    def num_actuated_dofs(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def num_actuators(self) -> int: ...
    def num_bodies(self) -> int: ...
    def num_collision_geometries(self) -> int: ...
    def num_constraints(self) -> int: ...
    def num_force_elements(self) -> int: ...
    def num_frames(self) -> int: ...
    def num_joints(self) -> int: ...
    def num_model_instances(self) -> int: ...
    @overload
    def num_multibody_states(self) -> int: ...
    @overload
    def num_multibody_states(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_positions(self) -> int: ...
    @overload
    def num_positions(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    @overload
    def num_velocities(self) -> int: ...
    @overload
    def num_velocities(self, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -> int: ...
    def physical_models(self) -> List[PhysicalModel]: ...
    def set_contact_model(self, model: ContactModel) -> None: ...
    def set_contact_surface_representation(self, surface_representation: pydrake.geometry.HydroelasticContactRepresentation) -> None: ...
    def set_discrete_contact_solver(self, contact_solver: DiscreteContactSolver) -> None: ...
    def set_penetration_allowance(self, penetration_allowance: float = ...) -> None: ...
    def set_stiction_tolerance(self, v_stiction: float = ...) -> None: ...
    def time_step(self) -> float: ...
    def world_body(self) -> pydrake.multibody.tree.RigidBody_[float]: ...
    def world_frame(self) -> pydrake.multibody.tree.BodyFrame_[float]: ...

class _TemporaryName_N5drake9multibody15CoulombFrictionIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: pydrake.autodiffutils.AutoDiffXd, dynamic_friction: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def dynamic_friction(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def static_friction(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> CoulombFriction_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_[AutoDiffXd]: ...
    def __getstate__(self) -> Tuple[pydrake.autodiffutils.AutoDiffXd,pydrake.autodiffutils.AutoDiffXd]: ...
    def __setstate__(self, arg0: Tuple[pydrake.autodiffutils.AutoDiffXd,pydrake.autodiffutils.AutoDiffXd]) -> None: ...

class _TemporaryName_N5drake9multibody15CoulombFrictionINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: pydrake.symbolic.Expression, dynamic_friction: pydrake.symbolic.Expression) -> None: ...
    def dynamic_friction(self) -> pydrake.symbolic.Expression: ...
    def static_friction(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> CoulombFriction_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_[Expression]: ...
    def __getstate__(self) -> Tuple[pydrake.symbolic.Expression,pydrake.symbolic.Expression]: ...
    def __setstate__(self, arg0: Tuple[pydrake.symbolic.Expression,pydrake.symbolic.Expression]) -> None: ...

class _TemporaryName_N5drake9multibody15CoulombFrictionIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, static_friction: float, dynamic_friction: float) -> None: ...
    def dynamic_friction(self) -> float: ...
    def static_friction(self) -> float: ...
    def __copy__(self) -> CoulombFriction_[float]: ...
    def __deepcopy__(self, arg0: dict) -> CoulombFriction_[float]: ...
    def __getstate__(self) -> Tuple[float,float]: ...
    def __setstate__(self, arg0: Tuple[float,float]) -> None: ...

class _TemporaryName_N5drake9multibody20PointPairContactInfoIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3,1]], p_WC: numpy.ndarray[object[3,1]], separation_speed: pydrake.autodiffutils.AutoDiffXd, slip_speed: pydrake.autodiffutils.AutoDiffXd, point_pair: pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd]) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[object[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[object[3,1]]: ...
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd]: ...
    def separation_speed(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def slip_speed(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> PointPairContactInfo_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_[AutoDiffXd]: ...

class _TemporaryName_N5drake9multibody20PointPairContactInfoINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3,1]], p_WC: numpy.ndarray[object[3,1]], separation_speed: pydrake.symbolic.Expression, slip_speed: pydrake.symbolic.Expression, point_pair: pydrake.geometry.PenetrationAsPointPair_[Expression]) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[object[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[object[3,1]]: ...
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_[Expression]: ...
    def separation_speed(self) -> pydrake.symbolic.Expression: ...
    def slip_speed(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> PointPairContactInfo_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_[Expression]: ...

class _TemporaryName_N5drake9multibody20PointPairContactInfoIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[numpy.float64[3,1]], p_WC: numpy.ndarray[numpy.float64[3,1]], separation_speed: float, slip_speed: float, point_pair: pydrake.geometry.PenetrationAsPointPair_[float]) -> None: ...
    def bodyA_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def bodyB_index(self) -> pydrake.multibody.tree.BodyIndex: ...
    def contact_force(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def contact_point(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def point_pair(self) -> pydrake.geometry.PenetrationAsPointPair_[float]: ...
    def separation_speed(self) -> float: ...
    def slip_speed(self) -> float: ...
    def __copy__(self) -> PointPairContactInfo_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PointPairContactInfo_[float]: ...

class _TemporaryName_N5drake9multibody23HydroelasticContactInfoIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_[AutoDiffXd]: ...
    def contact_surface(self) -> pydrake.geometry.ContactSurface_[AutoDiffXd]: ...
    def __copy__(self) -> HydroelasticContactInfo_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_[AutoDiffXd]: ...

class _TemporaryName_N5drake9multibody23HydroelasticContactInfoINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_[Expression]: ...
    def contact_surface(self, *args, **kwargs) -> Any: ...
    def __copy__(self) -> HydroelasticContactInfo_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_[Expression]: ...

class _TemporaryName_N5drake9multibody23HydroelasticContactInfoIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def F_Ac_W(self) -> pydrake.multibody.math.SpatialForce_[float]: ...
    def contact_surface(self) -> pydrake.geometry.ContactSurface_[float]: ...
    def __copy__(self) -> HydroelasticContactInfo_[float]: ...
    def __deepcopy__(self, arg0: dict) -> HydroelasticContactInfo_[float]: ...

class _TemporaryName_N5drake9multibody29ExternallyAppliedSpatialForceIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_[AutoDiffXd]
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[object[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_[AutoDiffXd]: ...

class _TemporaryName_N5drake9multibody29ExternallyAppliedSpatialForceINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_[Expression]
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[object[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_[Expression]: ...

class _TemporaryName_N5drake9multibody29ExternallyAppliedSpatialForceIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    F_Bq_W: pydrake.multibody.math.SpatialForce_[float]
    body_index: pydrake.multibody.tree.BodyIndex
    p_BoBq_B: numpy.ndarray[numpy.float64[3,1]]
    def __init__(self) -> None: ...
    def __copy__(self) -> ExternallyAppliedSpatialForce_[float]: ...
    def __deepcopy__(self, arg0: dict) -> ExternallyAppliedSpatialForce_[float]: ...

class _TemporaryName_N5drake9multibody40ExternallyAppliedSpatialForceMultiplexerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class _TemporaryName_N5drake9multibody40ExternallyAppliedSpatialForceMultiplexerINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class _TemporaryName_N5drake9multibody40ExternallyAppliedSpatialForceMultiplexerIdEE(pydrake.systems.framework.LeafSystem_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, num_inputs: int) -> None: ...

class _TemporaryName_N5drake9multibody4WingIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform_[float] = ..., fluid_density: float = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...

class _TemporaryName_N5drake9multibody4WingINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform_[float] = ..., fluid_density: float = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...

class _TemporaryName_N5drake9multibody4WingIdEE(pydrake.systems.framework.LeafSystem_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, surface_area: float, X_BodyWing: pydrake.math.RigidTransform_[float] = ..., fluid_density: float = ...) -> None: ...
    def AddToBuilder(self, *args, **kwargs) -> Any: ...
    def get_aerodynamic_center_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_body_spatial_velocities_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_fluid_density_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_spatial_force_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def get_wind_velocity_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...

class _TemporaryName_N5drake9multibody9PropellerIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(pydrake.systems.framework.LeafSystem_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform_[float] = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_[AutoDiffXd]: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[AutoDiffXd]: ...
    def num_propellers(self) -> int: ...

class _TemporaryName_N5drake9multibody9PropellerINS_8symbolic10ExpressionEEE(pydrake.systems.framework.LeafSystem_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform_[float] = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_[Expression]: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[Expression]: ...
    def num_propellers(self) -> int: ...

class _TemporaryName_N5drake9multibody9PropellerIdEE(pydrake.systems.framework.LeafSystem_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform_[float] = ..., thrust_ratio: float = ..., moment_ratio: float = ...) -> None: ...
    @overload
    def __init__(self, propeller_info: List[PropellerInfo]) -> None: ...
    def get_body_poses_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_command_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_spatial_forces_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def num_propellers(self) -> int: ...

def AddMultibodyPlant(config: MultibodyPlantConfig, builder: pydrake.systems.framework.DiagramBuilder_[float]) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[float], plant: MultibodyPlant_[float], scene_graph: pydrake.geometry.SceneGraph_[float] = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[float], time_step: float, scene_graph: pydrake.geometry.SceneGraph_[float] = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], plant: MultibodyPlant_[AutoDiffXd], scene_graph: pydrake.geometry.SceneGraph_[AutoDiffXd] = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], time_step: float, scene_graph: pydrake.geometry.SceneGraph_[AutoDiffXd] = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[Expression], plant: MultibodyPlant_[Expression], scene_graph: pydrake.geometry.SceneGraph_[Expression] = ...) -> tuple: ...
@overload
def AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[Expression], time_step: float, scene_graph: pydrake.geometry.SceneGraph_[Expression] = ...) -> tuple: ...
@overload
def CalcContactFrictionFromSurfaceProperties(surface_properties1: CoulombFriction_[float], surface_properties2: CoulombFriction_[float]) -> CoulombFriction_[float]: ...
@overload
def CalcContactFrictionFromSurfaceProperties(surface_properties1: CoulombFriction_[AutoDiffXd], surface_properties2: CoulombFriction_[AutoDiffXd]) -> CoulombFriction_[AutoDiffXd]: ...
@overload
def CalcContactFrictionFromSurfaceProperties(surface_properties1: CoulombFriction_[Expression], surface_properties2: CoulombFriction_[Expression]) -> CoulombFriction_[Expression]: ...
def ConnectContactResultsToDrakeVisualizer(builder: pydrake.systems.framework.DiagramBuilder_[float], plant, scene_graph: pydrake.geometry.SceneGraph_[float], lcm: pydrake.lcm.DrakeLcmInterface = ..., publish_period: Optional[float] = ...) -> pydrake.systems.lcm.LcmPublisherSystem: ...
